// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'schema.schema.gql.dart';

// **************************************************************************
// BuiltValueGenerator
// **************************************************************************

const GBetSettlement _$gBetSettlementCancelled =
    const GBetSettlement._('Cancelled');
const GBetSettlement _$gBetSettlementHalfLost =
    const GBetSettlement._('HalfLost');
const GBetSettlement _$gBetSettlementHalfWon =
    const GBetSettlement._('HalfWon');
const GBetSettlement _$gBetSettlementLoser = const GBetSettlement._('Loser');
const GBetSettlement _$gBetSettlementRefund = const GBetSettlement._('Refund');
const GBetSettlement _$gBetSettlementWinner = const GBetSettlement._('Winner');

GBetSettlement _$gBetSettlementValueOf(String name) {
  switch (name) {
    case 'Cancelled':
      return _$gBetSettlementCancelled;
    case 'HalfLost':
      return _$gBetSettlementHalfLost;
    case 'HalfWon':
      return _$gBetSettlementHalfWon;
    case 'Loser':
      return _$gBetSettlementLoser;
    case 'Refund':
      return _$gBetSettlementRefund;
    case 'Winner':
      return _$gBetSettlementWinner;
    default:
      throw new ArgumentError(name);
  }
}

final BuiltSet<GBetSettlement> _$gBetSettlementValues =
    new BuiltSet<GBetSettlement>(const <GBetSettlement>[
  _$gBetSettlementCancelled,
  _$gBetSettlementHalfLost,
  _$gBetSettlementHalfWon,
  _$gBetSettlementLoser,
  _$gBetSettlementRefund,
  _$gBetSettlementWinner,
]);

const GCashierPermission _$gCashierPermissionCREATE_DEPOSIT =
    const GCashierPermission._('CREATE_DEPOSIT');
const GCashierPermission _$gCashierPermissionCREATE_WITHDRAWAL =
    const GCashierPermission._('CREATE_WITHDRAWAL');
const GCashierPermission _$gCashierPermissionHANDLE_DEPOSIT_REQUEST =
    const GCashierPermission._('HANDLE_DEPOSIT_REQUEST');
const GCashierPermission _$gCashierPermissionPLACE_TICKETS =
    const GCashierPermission._('PLACE_TICKETS');

GCashierPermission _$gCashierPermissionValueOf(String name) {
  switch (name) {
    case 'CREATE_DEPOSIT':
      return _$gCashierPermissionCREATE_DEPOSIT;
    case 'CREATE_WITHDRAWAL':
      return _$gCashierPermissionCREATE_WITHDRAWAL;
    case 'HANDLE_DEPOSIT_REQUEST':
      return _$gCashierPermissionHANDLE_DEPOSIT_REQUEST;
    case 'PLACE_TICKETS':
      return _$gCashierPermissionPLACE_TICKETS;
    default:
      throw new ArgumentError(name);
  }
}

final BuiltSet<GCashierPermission> _$gCashierPermissionValues =
    new BuiltSet<GCashierPermission>(const <GCashierPermission>[
  _$gCashierPermissionCREATE_DEPOSIT,
  _$gCashierPermissionCREATE_WITHDRAWAL,
  _$gCashierPermissionHANDLE_DEPOSIT_REQUEST,
  _$gCashierPermissionPLACE_TICKETS,
]);

const GEvidenceType _$gEvidenceTypeTRANSACTION_ID =
    const GEvidenceType._('TRANSACTION_ID');
const GEvidenceType _$gEvidenceTypeTRANSACTION_PICTURE =
    const GEvidenceType._('TRANSACTION_PICTURE');

GEvidenceType _$gEvidenceTypeValueOf(String name) {
  switch (name) {
    case 'TRANSACTION_ID':
      return _$gEvidenceTypeTRANSACTION_ID;
    case 'TRANSACTION_PICTURE':
      return _$gEvidenceTypeTRANSACTION_PICTURE;
    default:
      throw new ArgumentError(name);
  }
}

final BuiltSet<GEvidenceType> _$gEvidenceTypeValues =
    new BuiltSet<GEvidenceType>(const <GEvidenceType>[
  _$gEvidenceTypeTRANSACTION_ID,
  _$gEvidenceTypeTRANSACTION_PICTURE,
]);

const GIncidentType _$gIncidentTypeBaseball_Hits =
    const GIncidentType._('Baseball_Hits');
const GIncidentType _$gIncidentTypeBasketball_Fouls =
    const GIncidentType._('Basketball_Fouls');
const GIncidentType _$gIncidentTypeBasketball_Free_throws =
    const GIncidentType._('Basketball_Free_throws');
const GIncidentType _$gIncidentTypeBasketball_Three_points =
    const GIncidentType._('Basketball_Three_points');
const GIncidentType _$gIncidentTypeBasketball_Time_outs =
    const GIncidentType._('Basketball_Time_outs');
const GIncidentType _$gIncidentTypeBasketball_Two_points =
    const GIncidentType._('Basketball_Two_points');
const GIncidentType _$gIncidentTypeFootball_Corners =
    const GIncidentType._('Football_Corners');
const GIncidentType _$gIncidentTypeFootball_Goal =
    const GIncidentType._('Football_Goal');
const GIncidentType _$gIncidentTypeFootball_Missed_penalty =
    const GIncidentType._('Football_Missed_penalty');
const GIncidentType _$gIncidentTypeFootball_Own_goal =
    const GIncidentType._('Football_Own_goal');
const GIncidentType _$gIncidentTypeFootball_Penalties =
    const GIncidentType._('Football_Penalties');
const GIncidentType _$gIncidentTypeFootball_Penalty_goal =
    const GIncidentType._('Football_Penalty_goal');
const GIncidentType _$gIncidentTypeFootball_Red_cards =
    const GIncidentType._('Football_Red_cards');
const GIncidentType _$gIncidentTypeFootball_Substitutions =
    const GIncidentType._('Football_Substitutions');
const GIncidentType _$gIncidentTypeFootball_Yellow_cards =
    const GIncidentType._('Football_Yellow_cards');
const GIncidentType _$gIncidentTypeIceHockey_Penalties =
    const GIncidentType._('IceHockey_Penalties');
const GIncidentType _$gIncidentTypeTennis_Aces =
    const GIncidentType._('Tennis_Aces');
const GIncidentType _$gIncidentTypeTennis_Double_faults =
    const GIncidentType._('Tennis_Double_faults');
const GIncidentType _$gIncidentTypeTennis_First_serve_wins =
    const GIncidentType._('Tennis_First_serve_wins');

GIncidentType _$gIncidentTypeValueOf(String name) {
  switch (name) {
    case 'Baseball_Hits':
      return _$gIncidentTypeBaseball_Hits;
    case 'Basketball_Fouls':
      return _$gIncidentTypeBasketball_Fouls;
    case 'Basketball_Free_throws':
      return _$gIncidentTypeBasketball_Free_throws;
    case 'Basketball_Three_points':
      return _$gIncidentTypeBasketball_Three_points;
    case 'Basketball_Time_outs':
      return _$gIncidentTypeBasketball_Time_outs;
    case 'Basketball_Two_points':
      return _$gIncidentTypeBasketball_Two_points;
    case 'Football_Corners':
      return _$gIncidentTypeFootball_Corners;
    case 'Football_Goal':
      return _$gIncidentTypeFootball_Goal;
    case 'Football_Missed_penalty':
      return _$gIncidentTypeFootball_Missed_penalty;
    case 'Football_Own_goal':
      return _$gIncidentTypeFootball_Own_goal;
    case 'Football_Penalties':
      return _$gIncidentTypeFootball_Penalties;
    case 'Football_Penalty_goal':
      return _$gIncidentTypeFootball_Penalty_goal;
    case 'Football_Red_cards':
      return _$gIncidentTypeFootball_Red_cards;
    case 'Football_Substitutions':
      return _$gIncidentTypeFootball_Substitutions;
    case 'Football_Yellow_cards':
      return _$gIncidentTypeFootball_Yellow_cards;
    case 'IceHockey_Penalties':
      return _$gIncidentTypeIceHockey_Penalties;
    case 'Tennis_Aces':
      return _$gIncidentTypeTennis_Aces;
    case 'Tennis_Double_faults':
      return _$gIncidentTypeTennis_Double_faults;
    case 'Tennis_First_serve_wins':
      return _$gIncidentTypeTennis_First_serve_wins;
    default:
      throw new ArgumentError(name);
  }
}

final BuiltSet<GIncidentType> _$gIncidentTypeValues =
    new BuiltSet<GIncidentType>(const <GIncidentType>[
  _$gIncidentTypeBaseball_Hits,
  _$gIncidentTypeBasketball_Fouls,
  _$gIncidentTypeBasketball_Free_throws,
  _$gIncidentTypeBasketball_Three_points,
  _$gIncidentTypeBasketball_Time_outs,
  _$gIncidentTypeBasketball_Two_points,
  _$gIncidentTypeFootball_Corners,
  _$gIncidentTypeFootball_Goal,
  _$gIncidentTypeFootball_Missed_penalty,
  _$gIncidentTypeFootball_Own_goal,
  _$gIncidentTypeFootball_Penalties,
  _$gIncidentTypeFootball_Penalty_goal,
  _$gIncidentTypeFootball_Red_cards,
  _$gIncidentTypeFootball_Substitutions,
  _$gIncidentTypeFootball_Yellow_cards,
  _$gIncidentTypeIceHockey_Penalties,
  _$gIncidentTypeTennis_Aces,
  _$gIncidentTypeTennis_Double_faults,
  _$gIncidentTypeTennis_First_serve_wins,
]);

const GPlacerType _$gPlacerTypeCASHIER = const GPlacerType._('CASHIER');
const GPlacerType _$gPlacerTypeCUSTOMER = const GPlacerType._('CUSTOMER');
const GPlacerType _$gPlacerTypeGUEST = const GPlacerType._('GUEST');

GPlacerType _$gPlacerTypeValueOf(String name) {
  switch (name) {
    case 'CASHIER':
      return _$gPlacerTypeCASHIER;
    case 'CUSTOMER':
      return _$gPlacerTypeCUSTOMER;
    case 'GUEST':
      return _$gPlacerTypeGUEST;
    default:
      throw new ArgumentError(name);
  }
}

final BuiltSet<GPlacerType> _$gPlacerTypeValues =
    new BuiltSet<GPlacerType>(const <GPlacerType>[
  _$gPlacerTypeCASHIER,
  _$gPlacerTypeCUSTOMER,
  _$gPlacerTypeGUEST,
]);

const GRole _$gRoleADMIN = const GRole._('ADMIN');
const GRole _$gRoleCASHIER = const GRole._('CASHIER');
const GRole _$gRoleCUSTOMER = const GRole._('CUSTOMER');
const GRole _$gRoleSUPER_ADMIN = const GRole._('SUPER_ADMIN');

GRole _$gRoleValueOf(String name) {
  switch (name) {
    case 'ADMIN':
      return _$gRoleADMIN;
    case 'CASHIER':
      return _$gRoleCASHIER;
    case 'CUSTOMER':
      return _$gRoleCUSTOMER;
    case 'SUPER_ADMIN':
      return _$gRoleSUPER_ADMIN;
    default:
      throw new ArgumentError(name);
  }
}

final BuiltSet<GRole> _$gRoleValues = new BuiltSet<GRole>(const <GRole>[
  _$gRoleADMIN,
  _$gRoleCASHIER,
  _$gRoleCUSTOMER,
  _$gRoleSUPER_ADMIN,
]);

const GScoreboardStatus _$gScoreboardStatusAbandoned =
    const GScoreboardStatus._('Abandoned');
const GScoreboardStatus _$gScoreboardStatusAbout_to_start =
    const GScoreboardStatus._('About_to_start');
const GScoreboardStatus _$gScoreboardStatusCancelled =
    const GScoreboardStatus._('Cancelled');
const GScoreboardStatus _$gScoreboardStatusCoverage_lost =
    const GScoreboardStatus._('Coverage_lost');
const GScoreboardStatus _$gScoreboardStatusFinished =
    const GScoreboardStatus._('Finished');
const GScoreboardStatus _$gScoreboardStatusIn_progress =
    const GScoreboardStatus._('In_progress');
const GScoreboardStatus _$gScoreboardStatusInterrupted =
    const GScoreboardStatus._('Interrupted');
const GScoreboardStatus _$gScoreboardStatusNot_started_yet =
    const GScoreboardStatus._('Not_started_yet');
const GScoreboardStatus _$gScoreboardStatusPostponed =
    const GScoreboardStatus._('Postponed');

GScoreboardStatus _$gScoreboardStatusValueOf(String name) {
  switch (name) {
    case 'Abandoned':
      return _$gScoreboardStatusAbandoned;
    case 'About_to_start':
      return _$gScoreboardStatusAbout_to_start;
    case 'Cancelled':
      return _$gScoreboardStatusCancelled;
    case 'Coverage_lost':
      return _$gScoreboardStatusCoverage_lost;
    case 'Finished':
      return _$gScoreboardStatusFinished;
    case 'In_progress':
      return _$gScoreboardStatusIn_progress;
    case 'Interrupted':
      return _$gScoreboardStatusInterrupted;
    case 'Not_started_yet':
      return _$gScoreboardStatusNot_started_yet;
    case 'Postponed':
      return _$gScoreboardStatusPostponed;
    default:
      throw new ArgumentError(name);
  }
}

final BuiltSet<GScoreboardStatus> _$gScoreboardStatusValues =
    new BuiltSet<GScoreboardStatus>(const <GScoreboardStatus>[
  _$gScoreboardStatusAbandoned,
  _$gScoreboardStatusAbout_to_start,
  _$gScoreboardStatusCancelled,
  _$gScoreboardStatusCoverage_lost,
  _$gScoreboardStatusFinished,
  _$gScoreboardStatusIn_progress,
  _$gScoreboardStatusInterrupted,
  _$gScoreboardStatusNot_started_yet,
  _$gScoreboardStatusPostponed,
]);

const GTicketStatus _$gTicketStatusLOSE = const GTicketStatus._('LOSE');
const GTicketStatus _$gTicketStatusPENDING = const GTicketStatus._('PENDING');
const GTicketStatus _$gTicketStatusWIN = const GTicketStatus._('WIN');

GTicketStatus _$gTicketStatusValueOf(String name) {
  switch (name) {
    case 'LOSE':
      return _$gTicketStatusLOSE;
    case 'PENDING':
      return _$gTicketStatusPENDING;
    case 'WIN':
      return _$gTicketStatusWIN;
    default:
      throw new ArgumentError(name);
  }
}

final BuiltSet<GTicketStatus> _$gTicketStatusValues =
    new BuiltSet<GTicketStatus>(const <GTicketStatus>[
  _$gTicketStatusLOSE,
  _$gTicketStatusPENDING,
  _$gTicketStatusWIN,
]);

const GTransactionType _$gTransactionTypeDEPOSIT =
    const GTransactionType._('DEPOSIT');
const GTransactionType _$gTransactionTypeWITHDRAW =
    const GTransactionType._('WITHDRAW');

GTransactionType _$gTransactionTypeValueOf(String name) {
  switch (name) {
    case 'DEPOSIT':
      return _$gTransactionTypeDEPOSIT;
    case 'WITHDRAW':
      return _$gTransactionTypeWITHDRAW;
    default:
      throw new ArgumentError(name);
  }
}

final BuiltSet<GTransactionType> _$gTransactionTypeValues =
    new BuiltSet<GTransactionType>(const <GTransactionType>[
  _$gTransactionTypeDEPOSIT,
  _$gTransactionTypeWITHDRAW,
]);

const GTransferSource _$gTransferSourceAMOLE = const GTransferSource._('AMOLE');
const GTransferSource _$gTransferSourceBANK = const GTransferSource._('BANK');
const GTransferSource _$gTransferSourceCBE = const GTransferSource._('CBE');
const GTransferSource _$gTransferSourceMBIRR = const GTransferSource._('MBIRR');

GTransferSource _$gTransferSourceValueOf(String name) {
  switch (name) {
    case 'AMOLE':
      return _$gTransferSourceAMOLE;
    case 'BANK':
      return _$gTransferSourceBANK;
    case 'CBE':
      return _$gTransferSourceCBE;
    case 'MBIRR':
      return _$gTransferSourceMBIRR;
    default:
      throw new ArgumentError(name);
  }
}

final BuiltSet<GTransferSource> _$gTransferSourceValues =
    new BuiltSet<GTransferSource>(const <GTransferSource>[
  _$gTransferSourceAMOLE,
  _$gTransferSourceBANK,
  _$gTransferSourceCBE,
  _$gTransferSourceMBIRR,
]);

const GUsernameType _$gUsernameTypeEMAIL = const GUsernameType._('EMAIL');
const GUsernameType _$gUsernameTypePHONE = const GUsernameType._('PHONE');

GUsernameType _$gUsernameTypeValueOf(String name) {
  switch (name) {
    case 'EMAIL':
      return _$gUsernameTypeEMAIL;
    case 'PHONE':
      return _$gUsernameTypePHONE;
    default:
      throw new ArgumentError(name);
  }
}

final BuiltSet<GUsernameType> _$gUsernameTypeValues =
    new BuiltSet<GUsernameType>(const <GUsernameType>[
  _$gUsernameTypeEMAIL,
  _$gUsernameTypePHONE,
]);

Serializer<GBetSettlement> _$gBetSettlementSerializer =
    new _$GBetSettlementSerializer();
Serializer<GCashierPermission> _$gCashierPermissionSerializer =
    new _$GCashierPermissionSerializer();
Serializer<GEvidenceType> _$gEvidenceTypeSerializer =
    new _$GEvidenceTypeSerializer();
Serializer<GIncidentType> _$gIncidentTypeSerializer =
    new _$GIncidentTypeSerializer();
Serializer<GPlacerType> _$gPlacerTypeSerializer = new _$GPlacerTypeSerializer();
Serializer<GRole> _$gRoleSerializer = new _$GRoleSerializer();
Serializer<GScoreboardStatus> _$gScoreboardStatusSerializer =
    new _$GScoreboardStatusSerializer();
Serializer<GTicketStatus> _$gTicketStatusSerializer =
    new _$GTicketStatusSerializer();
Serializer<GTransactionType> _$gTransactionTypeSerializer =
    new _$GTransactionTypeSerializer();
Serializer<GTransferSource> _$gTransferSourceSerializer =
    new _$GTransferSourceSerializer();
Serializer<GUsernameType> _$gUsernameTypeSerializer =
    new _$GUsernameTypeSerializer();
Serializer<GAdvertisementDTO> _$gAdvertisementDTOSerializer =
    new _$GAdvertisementDTOSerializer();
Serializer<GAppDto> _$gAppDtoSerializer = new _$GAppDtoSerializer();
Serializer<GBetDTO> _$gBetDTOSerializer = new _$GBetDTOSerializer();
Serializer<GContactDTO> _$gContactDTOSerializer = new _$GContactDTOSerializer();
Serializer<GCountryDTO> _$gCountryDTOSerializer = new _$GCountryDTOSerializer();
Serializer<GDepositRequestDto> _$gDepositRequestDtoSerializer =
    new _$GDepositRequestDtoSerializer();
Serializer<GFixtureDTO> _$gFixtureDTOSerializer = new _$GFixtureDTOSerializer();
Serializer<GLeagueDTO> _$gLeagueDTOSerializer = new _$GLeagueDTOSerializer();
Serializer<GLocationDTO> _$gLocationDTOSerializer =
    new _$GLocationDTOSerializer();
Serializer<GLoginDto> _$gLoginDtoSerializer = new _$GLoginDtoSerializer();
Serializer<GMarketDTO> _$gMarketDTOSerializer = new _$GMarketDTOSerializer();
Serializer<GShopDto> _$gShopDtoSerializer = new _$GShopDtoSerializer();
Serializer<GSportDTO> _$gSportDTOSerializer = new _$GSportDTOSerializer();
Serializer<GTicketDTO> _$gTicketDTOSerializer = new _$GTicketDTOSerializer();
Serializer<GTransactionDTO> _$gTransactionDTOSerializer =
    new _$GTransactionDTOSerializer();
Serializer<GUpdateDepositRequestDto> _$gUpdateDepositRequestDtoSerializer =
    new _$GUpdateDepositRequestDtoSerializer();
Serializer<GUpdateShopDTO> _$gUpdateShopDTOSerializer =
    new _$GUpdateShopDTOSerializer();
Serializer<GUpdateTicketDTO> _$gUpdateTicketDTOSerializer =
    new _$GUpdateTicketDTOSerializer();
Serializer<GUserDto> _$gUserDtoSerializer = new _$GUserDtoSerializer();
Serializer<GUserUpdateDTO> _$gUserUpdateDTOSerializer =
    new _$GUserUpdateDTOSerializer();

class _$GBetSettlementSerializer
    implements PrimitiveSerializer<GBetSettlement> {
  @override
  final Iterable<Type> types = const <Type>[GBetSettlement];
  @override
  final String wireName = 'GBetSettlement';

  @override
  Object serialize(Serializers serializers, GBetSettlement object,
          {FullType specifiedType = FullType.unspecified}) =>
      object.name;

  @override
  GBetSettlement deserialize(Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      GBetSettlement.valueOf(serialized as String);
}

class _$GCashierPermissionSerializer
    implements PrimitiveSerializer<GCashierPermission> {
  @override
  final Iterable<Type> types = const <Type>[GCashierPermission];
  @override
  final String wireName = 'GCashierPermission';

  @override
  Object serialize(Serializers serializers, GCashierPermission object,
          {FullType specifiedType = FullType.unspecified}) =>
      object.name;

  @override
  GCashierPermission deserialize(Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      GCashierPermission.valueOf(serialized as String);
}

class _$GEvidenceTypeSerializer implements PrimitiveSerializer<GEvidenceType> {
  @override
  final Iterable<Type> types = const <Type>[GEvidenceType];
  @override
  final String wireName = 'GEvidenceType';

  @override
  Object serialize(Serializers serializers, GEvidenceType object,
          {FullType specifiedType = FullType.unspecified}) =>
      object.name;

  @override
  GEvidenceType deserialize(Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      GEvidenceType.valueOf(serialized as String);
}

class _$GIncidentTypeSerializer implements PrimitiveSerializer<GIncidentType> {
  @override
  final Iterable<Type> types = const <Type>[GIncidentType];
  @override
  final String wireName = 'GIncidentType';

  @override
  Object serialize(Serializers serializers, GIncidentType object,
          {FullType specifiedType = FullType.unspecified}) =>
      object.name;

  @override
  GIncidentType deserialize(Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      GIncidentType.valueOf(serialized as String);
}

class _$GPlacerTypeSerializer implements PrimitiveSerializer<GPlacerType> {
  @override
  final Iterable<Type> types = const <Type>[GPlacerType];
  @override
  final String wireName = 'GPlacerType';

  @override
  Object serialize(Serializers serializers, GPlacerType object,
          {FullType specifiedType = FullType.unspecified}) =>
      object.name;

  @override
  GPlacerType deserialize(Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      GPlacerType.valueOf(serialized as String);
}

class _$GRoleSerializer implements PrimitiveSerializer<GRole> {
  @override
  final Iterable<Type> types = const <Type>[GRole];
  @override
  final String wireName = 'GRole';

  @override
  Object serialize(Serializers serializers, GRole object,
          {FullType specifiedType = FullType.unspecified}) =>
      object.name;

  @override
  GRole deserialize(Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      GRole.valueOf(serialized as String);
}

class _$GScoreboardStatusSerializer
    implements PrimitiveSerializer<GScoreboardStatus> {
  @override
  final Iterable<Type> types = const <Type>[GScoreboardStatus];
  @override
  final String wireName = 'GScoreboardStatus';

  @override
  Object serialize(Serializers serializers, GScoreboardStatus object,
          {FullType specifiedType = FullType.unspecified}) =>
      object.name;

  @override
  GScoreboardStatus deserialize(Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      GScoreboardStatus.valueOf(serialized as String);
}

class _$GTicketStatusSerializer implements PrimitiveSerializer<GTicketStatus> {
  @override
  final Iterable<Type> types = const <Type>[GTicketStatus];
  @override
  final String wireName = 'GTicketStatus';

  @override
  Object serialize(Serializers serializers, GTicketStatus object,
          {FullType specifiedType = FullType.unspecified}) =>
      object.name;

  @override
  GTicketStatus deserialize(Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      GTicketStatus.valueOf(serialized as String);
}

class _$GTransactionTypeSerializer
    implements PrimitiveSerializer<GTransactionType> {
  @override
  final Iterable<Type> types = const <Type>[GTransactionType];
  @override
  final String wireName = 'GTransactionType';

  @override
  Object serialize(Serializers serializers, GTransactionType object,
          {FullType specifiedType = FullType.unspecified}) =>
      object.name;

  @override
  GTransactionType deserialize(Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      GTransactionType.valueOf(serialized as String);
}

class _$GTransferSourceSerializer
    implements PrimitiveSerializer<GTransferSource> {
  @override
  final Iterable<Type> types = const <Type>[GTransferSource];
  @override
  final String wireName = 'GTransferSource';

  @override
  Object serialize(Serializers serializers, GTransferSource object,
          {FullType specifiedType = FullType.unspecified}) =>
      object.name;

  @override
  GTransferSource deserialize(Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      GTransferSource.valueOf(serialized as String);
}

class _$GUsernameTypeSerializer implements PrimitiveSerializer<GUsernameType> {
  @override
  final Iterable<Type> types = const <Type>[GUsernameType];
  @override
  final String wireName = 'GUsernameType';

  @override
  Object serialize(Serializers serializers, GUsernameType object,
          {FullType specifiedType = FullType.unspecified}) =>
      object.name;

  @override
  GUsernameType deserialize(Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      GUsernameType.valueOf(serialized as String);
}

class _$GAdvertisementDTOSerializer
    implements StructuredSerializer<GAdvertisementDTO> {
  @override
  final Iterable<Type> types = const [GAdvertisementDTO, _$GAdvertisementDTO];
  @override
  final String wireName = 'GAdvertisementDTO';

  @override
  Iterable<Object> serialize(Serializers serializers, GAdvertisementDTO object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object>[
      'imagePath',
      serializers.serialize(object.imagePath,
          specifiedType: const FullType(String)),
    ];
    if (object.id != null) {
      result
        ..add('id')
        ..add(serializers.serialize(object.id,
            specifiedType: const FullType(String)));
    }
    if (object.name != null) {
      result
        ..add('name')
        ..add(serializers.serialize(object.name,
            specifiedType: const FullType(String)));
    }
    if (object.position != null) {
      result
        ..add('position')
        ..add(serializers.serialize(object.position,
            specifiedType: const FullType(String)));
    }
    return result;
  }

  @override
  GAdvertisementDTO deserialize(
      Serializers serializers, Iterable<Object> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new GAdvertisementDTOBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final dynamic value = iterator.current;
      switch (key) {
        case 'id':
          result.id = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
        case 'imagePath':
          result.imagePath = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
        case 'name':
          result.name = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
        case 'position':
          result.position = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
      }
    }

    return result.build();
  }
}

class _$GAppDtoSerializer implements StructuredSerializer<GAppDto> {
  @override
  final Iterable<Type> types = const [GAppDto, _$GAppDto];
  @override
  final String wireName = 'GAppDto';

  @override
  Iterable<Object> serialize(Serializers serializers, GAppDto object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object>[
      'advertisements',
      serializers.serialize(object.advertisements,
          specifiedType: const FullType(
              BuiltList, const [const FullType(GAdvertisementDTO)])),
    ];
    if (object.appLogo != null) {
      result
        ..add('appLogo')
        ..add(serializers.serialize(object.appLogo,
            specifiedType: const FullType(String)));
    }
    if (object.appName != null) {
      result
        ..add('appName')
        ..add(serializers.serialize(object.appName,
            specifiedType: const FullType(String)));
    }
    if (object.bookmaker != null) {
      result
        ..add('bookmaker')
        ..add(serializers.serialize(object.bookmaker,
            specifiedType: const FullType(double)));
    }
    if (object.commissionRate != null) {
      result
        ..add('commissionRate')
        ..add(serializers.serialize(object.commissionRate,
            specifiedType: const FullType(double)));
    }
    if (object.maxStake != null) {
      result
        ..add('maxStake')
        ..add(serializers.serialize(object.maxStake,
            specifiedType: const FullType(double)));
    }
    if (object.maxWin != null) {
      result
        ..add('maxWin')
        ..add(serializers.serialize(object.maxWin,
            specifiedType: const FullType(double)));
    }
    if (object.minStake != null) {
      result
        ..add('minStake')
        ..add(serializers.serialize(object.minStake,
            specifiedType: const FullType(double)));
    }
    if (object.rules != null) {
      result
        ..add('rules')
        ..add(serializers.serialize(object.rules,
            specifiedType: const FullType(String)));
    }
    if (object.vatRate != null) {
      result
        ..add('vatRate')
        ..add(serializers.serialize(object.vatRate,
            specifiedType: const FullType(double)));
    }
    if (object.withdrawalLimit != null) {
      result
        ..add('withdrawalLimit')
        ..add(serializers.serialize(object.withdrawalLimit,
            specifiedType: const FullType(double)));
    }
    return result;
  }

  @override
  GAppDto deserialize(Serializers serializers, Iterable<Object> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new GAppDtoBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final dynamic value = iterator.current;
      switch (key) {
        case 'advertisements':
          result.advertisements.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(GAdvertisementDTO)]))
              as BuiltList<Object>);
          break;
        case 'appLogo':
          result.appLogo = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
        case 'appName':
          result.appName = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
        case 'bookmaker':
          result.bookmaker = serializers.deserialize(value,
              specifiedType: const FullType(double)) as double;
          break;
        case 'commissionRate':
          result.commissionRate = serializers.deserialize(value,
              specifiedType: const FullType(double)) as double;
          break;
        case 'maxStake':
          result.maxStake = serializers.deserialize(value,
              specifiedType: const FullType(double)) as double;
          break;
        case 'maxWin':
          result.maxWin = serializers.deserialize(value,
              specifiedType: const FullType(double)) as double;
          break;
        case 'minStake':
          result.minStake = serializers.deserialize(value,
              specifiedType: const FullType(double)) as double;
          break;
        case 'rules':
          result.rules = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
        case 'vatRate':
          result.vatRate = serializers.deserialize(value,
              specifiedType: const FullType(double)) as double;
          break;
        case 'withdrawalLimit':
          result.withdrawalLimit = serializers.deserialize(value,
              specifiedType: const FullType(double)) as double;
          break;
      }
    }

    return result.build();
  }
}

class _$GBetDTOSerializer implements StructuredSerializer<GBetDTO> {
  @override
  final Iterable<Type> types = const [GBetDTO, _$GBetDTO];
  @override
  final String wireName = 'GBetDTO';

  @override
  Iterable<Object> serialize(Serializers serializers, GBetDTO object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object>[
      'betId',
      serializers.serialize(object.betId,
          specifiedType: const FullType(String)),
      'fixtureId',
      serializers.serialize(object.fixtureId,
          specifiedType: const FullType(String)),
      'fixtureName',
      serializers.serialize(object.fixtureName,
          specifiedType: const FullType(String)),
      'oddValue',
      serializers.serialize(object.oddValue,
          specifiedType: const FullType(double)),
      'type',
      serializers.serialize(object.type, specifiedType: const FullType(String)),
      'value',
      serializers.serialize(object.value,
          specifiedType: const FullType(String)),
    ];

    return result;
  }

  @override
  GBetDTO deserialize(Serializers serializers, Iterable<Object> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new GBetDTOBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final dynamic value = iterator.current;
      switch (key) {
        case 'betId':
          result.betId = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
        case 'fixtureId':
          result.fixtureId = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
        case 'fixtureName':
          result.fixtureName = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
        case 'oddValue':
          result.oddValue = serializers.deserialize(value,
              specifiedType: const FullType(double)) as double;
          break;
        case 'type':
          result.type = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
        case 'value':
          result.value = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
      }
    }

    return result.build();
  }
}

class _$GContactDTOSerializer implements StructuredSerializer<GContactDTO> {
  @override
  final Iterable<Type> types = const [GContactDTO, _$GContactDTO];
  @override
  final String wireName = 'GContactDTO';

  @override
  Iterable<Object> serialize(Serializers serializers, GContactDTO object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object>[
      'type',
      serializers.serialize(object.type, specifiedType: const FullType(String)),
      'value',
      serializers.serialize(object.value,
          specifiedType: const FullType(String)),
    ];

    return result;
  }

  @override
  GContactDTO deserialize(Serializers serializers, Iterable<Object> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new GContactDTOBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final dynamic value = iterator.current;
      switch (key) {
        case 'type':
          result.type = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
        case 'value':
          result.value = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
      }
    }

    return result.build();
  }
}

class _$GCountryDTOSerializer implements StructuredSerializer<GCountryDTO> {
  @override
  final Iterable<Type> types = const [GCountryDTO, _$GCountryDTO];
  @override
  final String wireName = 'GCountryDTO';

  @override
  Iterable<Object> serialize(Serializers serializers, GCountryDTO object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object>[];
    if (object.isAvailable != null) {
      result
        ..add('isAvailable')
        ..add(serializers.serialize(object.isAvailable,
            specifiedType: const FullType(bool)));
    }
    if (object.order != null) {
      result
        ..add('order')
        ..add(serializers.serialize(object.order,
            specifiedType: const FullType(double)));
    }
    return result;
  }

  @override
  GCountryDTO deserialize(Serializers serializers, Iterable<Object> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new GCountryDTOBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final dynamic value = iterator.current;
      switch (key) {
        case 'isAvailable':
          result.isAvailable = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool;
          break;
        case 'order':
          result.order = serializers.deserialize(value,
              specifiedType: const FullType(double)) as double;
          break;
      }
    }

    return result.build();
  }
}

class _$GDepositRequestDtoSerializer
    implements StructuredSerializer<GDepositRequestDto> {
  @override
  final Iterable<Type> types = const [GDepositRequestDto, _$GDepositRequestDto];
  @override
  final String wireName = 'GDepositRequestDto';

  @override
  Iterable<Object> serialize(Serializers serializers, GDepositRequestDto object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object>[
      'evidence',
      serializers.serialize(object.evidence,
          specifiedType: const FullType(String)),
      'evidenceType',
      serializers.serialize(object.evidenceType,
          specifiedType: const FullType(GEvidenceType)),
      'transferSource',
      serializers.serialize(object.transferSource,
          specifiedType: const FullType(String)),
    ];

    return result;
  }

  @override
  GDepositRequestDto deserialize(
      Serializers serializers, Iterable<Object> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new GDepositRequestDtoBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final dynamic value = iterator.current;
      switch (key) {
        case 'evidence':
          result.evidence = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
        case 'evidenceType':
          result.evidenceType = serializers.deserialize(value,
              specifiedType: const FullType(GEvidenceType)) as GEvidenceType;
          break;
        case 'transferSource':
          result.transferSource = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
      }
    }

    return result.build();
  }
}

class _$GFixtureDTOSerializer implements StructuredSerializer<GFixtureDTO> {
  @override
  final Iterable<Type> types = const [GFixtureDTO, _$GFixtureDTO];
  @override
  final String wireName = 'GFixtureDTO';

  @override
  Iterable<Object> serialize(Serializers serializers, GFixtureDTO object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object>[
      'isAvailable',
      serializers.serialize(object.isAvailable,
          specifiedType: const FullType(bool)),
    ];

    return result;
  }

  @override
  GFixtureDTO deserialize(Serializers serializers, Iterable<Object> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new GFixtureDTOBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final dynamic value = iterator.current;
      switch (key) {
        case 'isAvailable':
          result.isAvailable = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool;
          break;
      }
    }

    return result.build();
  }
}

class _$GLeagueDTOSerializer implements StructuredSerializer<GLeagueDTO> {
  @override
  final Iterable<Type> types = const [GLeagueDTO, _$GLeagueDTO];
  @override
  final String wireName = 'GLeagueDTO';

  @override
  Iterable<Object> serialize(Serializers serializers, GLeagueDTO object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object>[];
    if (object.isAvailable != null) {
      result
        ..add('isAvailable')
        ..add(serializers.serialize(object.isAvailable,
            specifiedType: const FullType(bool)));
    }
    if (object.isTop != null) {
      result
        ..add('isTop')
        ..add(serializers.serialize(object.isTop,
            specifiedType: const FullType(bool)));
    }
    return result;
  }

  @override
  GLeagueDTO deserialize(Serializers serializers, Iterable<Object> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new GLeagueDTOBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final dynamic value = iterator.current;
      switch (key) {
        case 'isAvailable':
          result.isAvailable = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool;
          break;
        case 'isTop':
          result.isTop = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool;
          break;
      }
    }

    return result.build();
  }
}

class _$GLocationDTOSerializer implements StructuredSerializer<GLocationDTO> {
  @override
  final Iterable<Type> types = const [GLocationDTO, _$GLocationDTO];
  @override
  final String wireName = 'GLocationDTO';

  @override
  Iterable<Object> serialize(Serializers serializers, GLocationDTO object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object>[
      'lat',
      serializers.serialize(object.lat, specifiedType: const FullType(double)),
      'lon',
      serializers.serialize(object.lon, specifiedType: const FullType(double)),
    ];

    return result;
  }

  @override
  GLocationDTO deserialize(Serializers serializers, Iterable<Object> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new GLocationDTOBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final dynamic value = iterator.current;
      switch (key) {
        case 'lat':
          result.lat = serializers.deserialize(value,
              specifiedType: const FullType(double)) as double;
          break;
        case 'lon':
          result.lon = serializers.deserialize(value,
              specifiedType: const FullType(double)) as double;
          break;
      }
    }

    return result.build();
  }
}

class _$GLoginDtoSerializer implements StructuredSerializer<GLoginDto> {
  @override
  final Iterable<Type> types = const [GLoginDto, _$GLoginDto];
  @override
  final String wireName = 'GLoginDto';

  @override
  Iterable<Object> serialize(Serializers serializers, GLoginDto object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object>[
      'password',
      serializers.serialize(object.password,
          specifiedType: const FullType(String)),
      'username',
      serializers.serialize(object.username,
          specifiedType: const FullType(String)),
    ];

    return result;
  }

  @override
  GLoginDto deserialize(Serializers serializers, Iterable<Object> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new GLoginDtoBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final dynamic value = iterator.current;
      switch (key) {
        case 'password':
          result.password = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
        case 'username':
          result.username = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
      }
    }

    return result.build();
  }
}

class _$GMarketDTOSerializer implements StructuredSerializer<GMarketDTO> {
  @override
  final Iterable<Type> types = const [GMarketDTO, _$GMarketDTO];
  @override
  final String wireName = 'GMarketDTO';

  @override
  Iterable<Object> serialize(Serializers serializers, GMarketDTO object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object>[
      'isAvailable',
      serializers.serialize(object.isAvailable,
          specifiedType: const FullType(bool)),
    ];

    return result;
  }

  @override
  GMarketDTO deserialize(Serializers serializers, Iterable<Object> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new GMarketDTOBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final dynamic value = iterator.current;
      switch (key) {
        case 'isAvailable':
          result.isAvailable = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool;
          break;
      }
    }

    return result.build();
  }
}

class _$GShopDtoSerializer implements StructuredSerializer<GShopDto> {
  @override
  final Iterable<Type> types = const [GShopDto, _$GShopDto];
  @override
  final String wireName = 'GShopDto';

  @override
  Iterable<Object> serialize(Serializers serializers, GShopDto object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object>[
      'adminId',
      serializers.serialize(object.adminId,
          specifiedType: const FullType(String)),
      'branchName',
      serializers.serialize(object.branchName,
          specifiedType: const FullType(String)),
      'contacts',
      serializers.serialize(object.contacts,
          specifiedType:
              const FullType(BuiltList, const [const FullType(GContactDTO)])),
    ];
    if (object.isActive != null) {
      result
        ..add('isActive')
        ..add(serializers.serialize(object.isActive,
            specifiedType: const FullType(bool)));
    }
    if (object.location != null) {
      result
        ..add('location')
        ..add(serializers.serialize(object.location,
            specifiedType: const FullType(GLocationDTO)));
    }
    return result;
  }

  @override
  GShopDto deserialize(Serializers serializers, Iterable<Object> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new GShopDtoBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final dynamic value = iterator.current;
      switch (key) {
        case 'adminId':
          result.adminId = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
        case 'branchName':
          result.branchName = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
        case 'contacts':
          result.contacts.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(GContactDTO)]))
              as BuiltList<Object>);
          break;
        case 'isActive':
          result.isActive = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool;
          break;
        case 'location':
          result.location.replace(serializers.deserialize(value,
              specifiedType: const FullType(GLocationDTO)) as GLocationDTO);
          break;
      }
    }

    return result.build();
  }
}

class _$GSportDTOSerializer implements StructuredSerializer<GSportDTO> {
  @override
  final Iterable<Type> types = const [GSportDTO, _$GSportDTO];
  @override
  final String wireName = 'GSportDTO';

  @override
  Iterable<Object> serialize(Serializers serializers, GSportDTO object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object>[
      'isAvailable',
      serializers.serialize(object.isAvailable,
          specifiedType: const FullType(bool)),
    ];
    if (object.order != null) {
      result
        ..add('order')
        ..add(serializers.serialize(object.order,
            specifiedType: const FullType(double)));
    }
    return result;
  }

  @override
  GSportDTO deserialize(Serializers serializers, Iterable<Object> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new GSportDTOBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final dynamic value = iterator.current;
      switch (key) {
        case 'isAvailable':
          result.isAvailable = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool;
          break;
        case 'order':
          result.order = serializers.deserialize(value,
              specifiedType: const FullType(double)) as double;
          break;
      }
    }

    return result.build();
  }
}

class _$GTicketDTOSerializer implements StructuredSerializer<GTicketDTO> {
  @override
  final Iterable<Type> types = const [GTicketDTO, _$GTicketDTO];
  @override
  final String wireName = 'GTicketDTO';

  @override
  Iterable<Object> serialize(Serializers serializers, GTicketDTO object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object>[
      'bets',
      serializers.serialize(object.bets,
          specifiedType:
              const FullType(BuiltList, const [const FullType(GBetDTO)])),
      'stake',
      serializers.serialize(object.stake,
          specifiedType: const FullType(double)),
    ];

    return result;
  }

  @override
  GTicketDTO deserialize(Serializers serializers, Iterable<Object> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new GTicketDTOBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final dynamic value = iterator.current;
      switch (key) {
        case 'bets':
          result.bets.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(GBetDTO)]))
              as BuiltList<Object>);
          break;
        case 'stake':
          result.stake = serializers.deserialize(value,
              specifiedType: const FullType(double)) as double;
          break;
      }
    }

    return result.build();
  }
}

class _$GTransactionDTOSerializer
    implements StructuredSerializer<GTransactionDTO> {
  @override
  final Iterable<Type> types = const [GTransactionDTO, _$GTransactionDTO];
  @override
  final String wireName = 'GTransactionDTO';

  @override
  Iterable<Object> serialize(Serializers serializers, GTransactionDTO object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object>[
      'amount',
      serializers.serialize(object.amount,
          specifiedType: const FullType(double)),
      'customer',
      serializers.serialize(object.customer,
          specifiedType: const FullType(String)),
      'type',
      serializers.serialize(object.type,
          specifiedType: const FullType(GTransactionType)),
    ];

    return result;
  }

  @override
  GTransactionDTO deserialize(
      Serializers serializers, Iterable<Object> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new GTransactionDTOBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final dynamic value = iterator.current;
      switch (key) {
        case 'amount':
          result.amount = serializers.deserialize(value,
              specifiedType: const FullType(double)) as double;
          break;
        case 'customer':
          result.customer = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
        case 'type':
          result.type = serializers.deserialize(value,
                  specifiedType: const FullType(GTransactionType))
              as GTransactionType;
          break;
      }
    }

    return result.build();
  }
}

class _$GUpdateDepositRequestDtoSerializer
    implements StructuredSerializer<GUpdateDepositRequestDto> {
  @override
  final Iterable<Type> types = const [
    GUpdateDepositRequestDto,
    _$GUpdateDepositRequestDto
  ];
  @override
  final String wireName = 'GUpdateDepositRequestDto';

  @override
  Iterable<Object> serialize(
      Serializers serializers, GUpdateDepositRequestDto object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object>[
      'amount',
      serializers.serialize(object.amount,
          specifiedType: const FullType(double)),
    ];

    return result;
  }

  @override
  GUpdateDepositRequestDto deserialize(
      Serializers serializers, Iterable<Object> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new GUpdateDepositRequestDtoBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final dynamic value = iterator.current;
      switch (key) {
        case 'amount':
          result.amount = serializers.deserialize(value,
              specifiedType: const FullType(double)) as double;
          break;
      }
    }

    return result.build();
  }
}

class _$GUpdateShopDTOSerializer
    implements StructuredSerializer<GUpdateShopDTO> {
  @override
  final Iterable<Type> types = const [GUpdateShopDTO, _$GUpdateShopDTO];
  @override
  final String wireName = 'GUpdateShopDTO';

  @override
  Iterable<Object> serialize(Serializers serializers, GUpdateShopDTO object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object>[
      'contacts',
      serializers.serialize(object.contacts,
          specifiedType:
              const FullType(BuiltList, const [const FullType(GContactDTO)])),
    ];
    if (object.adminId != null) {
      result
        ..add('adminId')
        ..add(serializers.serialize(object.adminId,
            specifiedType: const FullType(String)));
    }
    if (object.branchName != null) {
      result
        ..add('branchName')
        ..add(serializers.serialize(object.branchName,
            specifiedType: const FullType(String)));
    }
    if (object.isActive != null) {
      result
        ..add('isActive')
        ..add(serializers.serialize(object.isActive,
            specifiedType: const FullType(bool)));
    }
    if (object.location != null) {
      result
        ..add('location')
        ..add(serializers.serialize(object.location,
            specifiedType: const FullType(GLocationDTO)));
    }
    return result;
  }

  @override
  GUpdateShopDTO deserialize(
      Serializers serializers, Iterable<Object> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new GUpdateShopDTOBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final dynamic value = iterator.current;
      switch (key) {
        case 'adminId':
          result.adminId = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
        case 'branchName':
          result.branchName = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
        case 'contacts':
          result.contacts.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(GContactDTO)]))
              as BuiltList<Object>);
          break;
        case 'isActive':
          result.isActive = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool;
          break;
        case 'location':
          result.location.replace(serializers.deserialize(value,
              specifiedType: const FullType(GLocationDTO)) as GLocationDTO);
          break;
      }
    }

    return result.build();
  }
}

class _$GUpdateTicketDTOSerializer
    implements StructuredSerializer<GUpdateTicketDTO> {
  @override
  final Iterable<Type> types = const [GUpdateTicketDTO, _$GUpdateTicketDTO];
  @override
  final String wireName = 'GUpdateTicketDTO';

  @override
  Iterable<Object> serialize(Serializers serializers, GUpdateTicketDTO object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object>[];
    if (object.isPlaced != null) {
      result
        ..add('isPlaced')
        ..add(serializers.serialize(object.isPlaced,
            specifiedType: const FullType(bool)));
    }
    if (object.stake != null) {
      result
        ..add('stake')
        ..add(serializers.serialize(object.stake,
            specifiedType: const FullType(double)));
    }
    return result;
  }

  @override
  GUpdateTicketDTO deserialize(
      Serializers serializers, Iterable<Object> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new GUpdateTicketDTOBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final dynamic value = iterator.current;
      switch (key) {
        case 'isPlaced':
          result.isPlaced = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool;
          break;
        case 'stake':
          result.stake = serializers.deserialize(value,
              specifiedType: const FullType(double)) as double;
          break;
      }
    }

    return result.build();
  }
}

class _$GUserDtoSerializer implements StructuredSerializer<GUserDto> {
  @override
  final Iterable<Type> types = const [GUserDto, _$GUserDto];
  @override
  final String wireName = 'GUserDto';

  @override
  Iterable<Object> serialize(Serializers serializers, GUserDto object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object>[
      'cashierPermissions',
      serializers.serialize(object.cashierPermissions,
          specifiedType: const FullType(
              BuiltList, const [const FullType(GCashierPermission)])),
      'firstName',
      serializers.serialize(object.firstName,
          specifiedType: const FullType(String)),
      'lastName',
      serializers.serialize(object.lastName,
          specifiedType: const FullType(String)),
      'password',
      serializers.serialize(object.password,
          specifiedType: const FullType(String)),
      'username',
      serializers.serialize(object.username,
          specifiedType: const FullType(String)),
    ];
    if (object.belongsToShop != null) {
      result
        ..add('belongsToShop')
        ..add(serializers.serialize(object.belongsToShop,
            specifiedType: const FullType(String)));
    }
    if (object.role != null) {
      result
        ..add('role')
        ..add(serializers.serialize(object.role,
            specifiedType: const FullType(GRole)));
    }
    return result;
  }

  @override
  GUserDto deserialize(Serializers serializers, Iterable<Object> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new GUserDtoBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final dynamic value = iterator.current;
      switch (key) {
        case 'belongsToShop':
          result.belongsToShop = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
        case 'cashierPermissions':
          result.cashierPermissions.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(GCashierPermission)]))
              as BuiltList<Object>);
          break;
        case 'firstName':
          result.firstName = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
        case 'lastName':
          result.lastName = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
        case 'password':
          result.password = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
        case 'role':
          result.role = serializers.deserialize(value,
              specifiedType: const FullType(GRole)) as GRole;
          break;
        case 'username':
          result.username = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
      }
    }

    return result.build();
  }
}

class _$GUserUpdateDTOSerializer
    implements StructuredSerializer<GUserUpdateDTO> {
  @override
  final Iterable<Type> types = const [GUserUpdateDTO, _$GUserUpdateDTO];
  @override
  final String wireName = 'GUserUpdateDTO';

  @override
  Iterable<Object> serialize(Serializers serializers, GUserUpdateDTO object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object>[
      'cashierPermissions',
      serializers.serialize(object.cashierPermissions,
          specifiedType: const FullType(
              BuiltList, const [const FullType(GCashierPermission)])),
    ];
    if (object.belongsToShop != null) {
      result
        ..add('belongsToShop')
        ..add(serializers.serialize(object.belongsToShop,
            specifiedType: const FullType(String)));
    }
    if (object.firstName != null) {
      result
        ..add('firstName')
        ..add(serializers.serialize(object.firstName,
            specifiedType: const FullType(String)));
    }
    if (object.lastName != null) {
      result
        ..add('lastName')
        ..add(serializers.serialize(object.lastName,
            specifiedType: const FullType(String)));
    }
    if (object.password != null) {
      result
        ..add('password')
        ..add(serializers.serialize(object.password,
            specifiedType: const FullType(String)));
    }
    if (object.role != null) {
      result
        ..add('role')
        ..add(serializers.serialize(object.role,
            specifiedType: const FullType(GRole)));
    }
    if (object.username != null) {
      result
        ..add('username')
        ..add(serializers.serialize(object.username,
            specifiedType: const FullType(String)));
    }
    return result;
  }

  @override
  GUserUpdateDTO deserialize(
      Serializers serializers, Iterable<Object> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new GUserUpdateDTOBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final dynamic value = iterator.current;
      switch (key) {
        case 'belongsToShop':
          result.belongsToShop = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
        case 'cashierPermissions':
          result.cashierPermissions.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(GCashierPermission)]))
              as BuiltList<Object>);
          break;
        case 'firstName':
          result.firstName = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
        case 'lastName':
          result.lastName = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
        case 'password':
          result.password = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
        case 'role':
          result.role = serializers.deserialize(value,
              specifiedType: const FullType(GRole)) as GRole;
          break;
        case 'username':
          result.username = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
      }
    }

    return result.build();
  }
}

class _$GAdvertisementDTO extends GAdvertisementDTO {
  @override
  final String id;
  @override
  final String imagePath;
  @override
  final String name;
  @override
  final String position;

  factory _$GAdvertisementDTO(
          [void Function(GAdvertisementDTOBuilder) updates]) =>
      (new GAdvertisementDTOBuilder()..update(updates)).build();

  _$GAdvertisementDTO._({this.id, this.imagePath, this.name, this.position})
      : super._() {
    if (imagePath == null) {
      throw new BuiltValueNullFieldError('GAdvertisementDTO', 'imagePath');
    }
  }

  @override
  GAdvertisementDTO rebuild(void Function(GAdvertisementDTOBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GAdvertisementDTOBuilder toBuilder() =>
      new GAdvertisementDTOBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GAdvertisementDTO &&
        id == other.id &&
        imagePath == other.imagePath &&
        name == other.name &&
        position == other.position;
  }

  @override
  int get hashCode {
    return $jf($jc(
        $jc($jc($jc(0, id.hashCode), imagePath.hashCode), name.hashCode),
        position.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GAdvertisementDTO')
          ..add('id', id)
          ..add('imagePath', imagePath)
          ..add('name', name)
          ..add('position', position))
        .toString();
  }
}

class GAdvertisementDTOBuilder
    implements Builder<GAdvertisementDTO, GAdvertisementDTOBuilder> {
  _$GAdvertisementDTO _$v;

  String _id;
  String get id => _$this._id;
  set id(String id) => _$this._id = id;

  String _imagePath;
  String get imagePath => _$this._imagePath;
  set imagePath(String imagePath) => _$this._imagePath = imagePath;

  String _name;
  String get name => _$this._name;
  set name(String name) => _$this._name = name;

  String _position;
  String get position => _$this._position;
  set position(String position) => _$this._position = position;

  GAdvertisementDTOBuilder();

  GAdvertisementDTOBuilder get _$this {
    if (_$v != null) {
      _id = _$v.id;
      _imagePath = _$v.imagePath;
      _name = _$v.name;
      _position = _$v.position;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GAdvertisementDTO other) {
    if (other == null) {
      throw new ArgumentError.notNull('other');
    }
    _$v = other as _$GAdvertisementDTO;
  }

  @override
  void update(void Function(GAdvertisementDTOBuilder) updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GAdvertisementDTO build() {
    final _$result = _$v ??
        new _$GAdvertisementDTO._(
            id: id, imagePath: imagePath, name: name, position: position);
    replace(_$result);
    return _$result;
  }
}

class _$GAppDto extends GAppDto {
  @override
  final BuiltList<GAdvertisementDTO> advertisements;
  @override
  final String appLogo;
  @override
  final String appName;
  @override
  final double bookmaker;
  @override
  final double commissionRate;
  @override
  final double maxStake;
  @override
  final double maxWin;
  @override
  final double minStake;
  @override
  final String rules;
  @override
  final double vatRate;
  @override
  final double withdrawalLimit;

  factory _$GAppDto([void Function(GAppDtoBuilder) updates]) =>
      (new GAppDtoBuilder()..update(updates)).build();

  _$GAppDto._(
      {this.advertisements,
      this.appLogo,
      this.appName,
      this.bookmaker,
      this.commissionRate,
      this.maxStake,
      this.maxWin,
      this.minStake,
      this.rules,
      this.vatRate,
      this.withdrawalLimit})
      : super._() {
    if (advertisements == null) {
      throw new BuiltValueNullFieldError('GAppDto', 'advertisements');
    }
  }

  @override
  GAppDto rebuild(void Function(GAppDtoBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GAppDtoBuilder toBuilder() => new GAppDtoBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GAppDto &&
        advertisements == other.advertisements &&
        appLogo == other.appLogo &&
        appName == other.appName &&
        bookmaker == other.bookmaker &&
        commissionRate == other.commissionRate &&
        maxStake == other.maxStake &&
        maxWin == other.maxWin &&
        minStake == other.minStake &&
        rules == other.rules &&
        vatRate == other.vatRate &&
        withdrawalLimit == other.withdrawalLimit;
  }

  @override
  int get hashCode {
    return $jf($jc(
        $jc(
            $jc(
                $jc(
                    $jc(
                        $jc(
                            $jc(
                                $jc(
                                    $jc(
                                        $jc($jc(0, advertisements.hashCode),
                                            appLogo.hashCode),
                                        appName.hashCode),
                                    bookmaker.hashCode),
                                commissionRate.hashCode),
                            maxStake.hashCode),
                        maxWin.hashCode),
                    minStake.hashCode),
                rules.hashCode),
            vatRate.hashCode),
        withdrawalLimit.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GAppDto')
          ..add('advertisements', advertisements)
          ..add('appLogo', appLogo)
          ..add('appName', appName)
          ..add('bookmaker', bookmaker)
          ..add('commissionRate', commissionRate)
          ..add('maxStake', maxStake)
          ..add('maxWin', maxWin)
          ..add('minStake', minStake)
          ..add('rules', rules)
          ..add('vatRate', vatRate)
          ..add('withdrawalLimit', withdrawalLimit))
        .toString();
  }
}

class GAppDtoBuilder implements Builder<GAppDto, GAppDtoBuilder> {
  _$GAppDto _$v;

  ListBuilder<GAdvertisementDTO> _advertisements;
  ListBuilder<GAdvertisementDTO> get advertisements =>
      _$this._advertisements ??= new ListBuilder<GAdvertisementDTO>();
  set advertisements(ListBuilder<GAdvertisementDTO> advertisements) =>
      _$this._advertisements = advertisements;

  String _appLogo;
  String get appLogo => _$this._appLogo;
  set appLogo(String appLogo) => _$this._appLogo = appLogo;

  String _appName;
  String get appName => _$this._appName;
  set appName(String appName) => _$this._appName = appName;

  double _bookmaker;
  double get bookmaker => _$this._bookmaker;
  set bookmaker(double bookmaker) => _$this._bookmaker = bookmaker;

  double _commissionRate;
  double get commissionRate => _$this._commissionRate;
  set commissionRate(double commissionRate) =>
      _$this._commissionRate = commissionRate;

  double _maxStake;
  double get maxStake => _$this._maxStake;
  set maxStake(double maxStake) => _$this._maxStake = maxStake;

  double _maxWin;
  double get maxWin => _$this._maxWin;
  set maxWin(double maxWin) => _$this._maxWin = maxWin;

  double _minStake;
  double get minStake => _$this._minStake;
  set minStake(double minStake) => _$this._minStake = minStake;

  String _rules;
  String get rules => _$this._rules;
  set rules(String rules) => _$this._rules = rules;

  double _vatRate;
  double get vatRate => _$this._vatRate;
  set vatRate(double vatRate) => _$this._vatRate = vatRate;

  double _withdrawalLimit;
  double get withdrawalLimit => _$this._withdrawalLimit;
  set withdrawalLimit(double withdrawalLimit) =>
      _$this._withdrawalLimit = withdrawalLimit;

  GAppDtoBuilder();

  GAppDtoBuilder get _$this {
    if (_$v != null) {
      _advertisements = _$v.advertisements?.toBuilder();
      _appLogo = _$v.appLogo;
      _appName = _$v.appName;
      _bookmaker = _$v.bookmaker;
      _commissionRate = _$v.commissionRate;
      _maxStake = _$v.maxStake;
      _maxWin = _$v.maxWin;
      _minStake = _$v.minStake;
      _rules = _$v.rules;
      _vatRate = _$v.vatRate;
      _withdrawalLimit = _$v.withdrawalLimit;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GAppDto other) {
    if (other == null) {
      throw new ArgumentError.notNull('other');
    }
    _$v = other as _$GAppDto;
  }

  @override
  void update(void Function(GAppDtoBuilder) updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GAppDto build() {
    _$GAppDto _$result;
    try {
      _$result = _$v ??
          new _$GAppDto._(
              advertisements: advertisements.build(),
              appLogo: appLogo,
              appName: appName,
              bookmaker: bookmaker,
              commissionRate: commissionRate,
              maxStake: maxStake,
              maxWin: maxWin,
              minStake: minStake,
              rules: rules,
              vatRate: vatRate,
              withdrawalLimit: withdrawalLimit);
    } catch (_) {
      String _$failedField;
      try {
        _$failedField = 'advertisements';
        advertisements.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'GAppDto', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$GBetDTO extends GBetDTO {
  @override
  final String betId;
  @override
  final String fixtureId;
  @override
  final String fixtureName;
  @override
  final double oddValue;
  @override
  final String type;
  @override
  final String value;

  factory _$GBetDTO([void Function(GBetDTOBuilder) updates]) =>
      (new GBetDTOBuilder()..update(updates)).build();

  _$GBetDTO._(
      {this.betId,
      this.fixtureId,
      this.fixtureName,
      this.oddValue,
      this.type,
      this.value})
      : super._() {
    if (betId == null) {
      throw new BuiltValueNullFieldError('GBetDTO', 'betId');
    }
    if (fixtureId == null) {
      throw new BuiltValueNullFieldError('GBetDTO', 'fixtureId');
    }
    if (fixtureName == null) {
      throw new BuiltValueNullFieldError('GBetDTO', 'fixtureName');
    }
    if (oddValue == null) {
      throw new BuiltValueNullFieldError('GBetDTO', 'oddValue');
    }
    if (type == null) {
      throw new BuiltValueNullFieldError('GBetDTO', 'type');
    }
    if (value == null) {
      throw new BuiltValueNullFieldError('GBetDTO', 'value');
    }
  }

  @override
  GBetDTO rebuild(void Function(GBetDTOBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GBetDTOBuilder toBuilder() => new GBetDTOBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GBetDTO &&
        betId == other.betId &&
        fixtureId == other.fixtureId &&
        fixtureName == other.fixtureName &&
        oddValue == other.oddValue &&
        type == other.type &&
        value == other.value;
  }

  @override
  int get hashCode {
    return $jf($jc(
        $jc(
            $jc(
                $jc($jc($jc(0, betId.hashCode), fixtureId.hashCode),
                    fixtureName.hashCode),
                oddValue.hashCode),
            type.hashCode),
        value.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GBetDTO')
          ..add('betId', betId)
          ..add('fixtureId', fixtureId)
          ..add('fixtureName', fixtureName)
          ..add('oddValue', oddValue)
          ..add('type', type)
          ..add('value', value))
        .toString();
  }
}

class GBetDTOBuilder implements Builder<GBetDTO, GBetDTOBuilder> {
  _$GBetDTO _$v;

  String _betId;
  String get betId => _$this._betId;
  set betId(String betId) => _$this._betId = betId;

  String _fixtureId;
  String get fixtureId => _$this._fixtureId;
  set fixtureId(String fixtureId) => _$this._fixtureId = fixtureId;

  String _fixtureName;
  String get fixtureName => _$this._fixtureName;
  set fixtureName(String fixtureName) => _$this._fixtureName = fixtureName;

  double _oddValue;
  double get oddValue => _$this._oddValue;
  set oddValue(double oddValue) => _$this._oddValue = oddValue;

  String _type;
  String get type => _$this._type;
  set type(String type) => _$this._type = type;

  String _value;
  String get value => _$this._value;
  set value(String value) => _$this._value = value;

  GBetDTOBuilder();

  GBetDTOBuilder get _$this {
    if (_$v != null) {
      _betId = _$v.betId;
      _fixtureId = _$v.fixtureId;
      _fixtureName = _$v.fixtureName;
      _oddValue = _$v.oddValue;
      _type = _$v.type;
      _value = _$v.value;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GBetDTO other) {
    if (other == null) {
      throw new ArgumentError.notNull('other');
    }
    _$v = other as _$GBetDTO;
  }

  @override
  void update(void Function(GBetDTOBuilder) updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GBetDTO build() {
    final _$result = _$v ??
        new _$GBetDTO._(
            betId: betId,
            fixtureId: fixtureId,
            fixtureName: fixtureName,
            oddValue: oddValue,
            type: type,
            value: value);
    replace(_$result);
    return _$result;
  }
}

class _$GContactDTO extends GContactDTO {
  @override
  final String type;
  @override
  final String value;

  factory _$GContactDTO([void Function(GContactDTOBuilder) updates]) =>
      (new GContactDTOBuilder()..update(updates)).build();

  _$GContactDTO._({this.type, this.value}) : super._() {
    if (type == null) {
      throw new BuiltValueNullFieldError('GContactDTO', 'type');
    }
    if (value == null) {
      throw new BuiltValueNullFieldError('GContactDTO', 'value');
    }
  }

  @override
  GContactDTO rebuild(void Function(GContactDTOBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GContactDTOBuilder toBuilder() => new GContactDTOBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GContactDTO && type == other.type && value == other.value;
  }

  @override
  int get hashCode {
    return $jf($jc($jc(0, type.hashCode), value.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GContactDTO')
          ..add('type', type)
          ..add('value', value))
        .toString();
  }
}

class GContactDTOBuilder implements Builder<GContactDTO, GContactDTOBuilder> {
  _$GContactDTO _$v;

  String _type;
  String get type => _$this._type;
  set type(String type) => _$this._type = type;

  String _value;
  String get value => _$this._value;
  set value(String value) => _$this._value = value;

  GContactDTOBuilder();

  GContactDTOBuilder get _$this {
    if (_$v != null) {
      _type = _$v.type;
      _value = _$v.value;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GContactDTO other) {
    if (other == null) {
      throw new ArgumentError.notNull('other');
    }
    _$v = other as _$GContactDTO;
  }

  @override
  void update(void Function(GContactDTOBuilder) updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GContactDTO build() {
    final _$result = _$v ?? new _$GContactDTO._(type: type, value: value);
    replace(_$result);
    return _$result;
  }
}

class _$GCountryDTO extends GCountryDTO {
  @override
  final bool isAvailable;
  @override
  final double order;

  factory _$GCountryDTO([void Function(GCountryDTOBuilder) updates]) =>
      (new GCountryDTOBuilder()..update(updates)).build();

  _$GCountryDTO._({this.isAvailable, this.order}) : super._();

  @override
  GCountryDTO rebuild(void Function(GCountryDTOBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GCountryDTOBuilder toBuilder() => new GCountryDTOBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GCountryDTO &&
        isAvailable == other.isAvailable &&
        order == other.order;
  }

  @override
  int get hashCode {
    return $jf($jc($jc(0, isAvailable.hashCode), order.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GCountryDTO')
          ..add('isAvailable', isAvailable)
          ..add('order', order))
        .toString();
  }
}

class GCountryDTOBuilder implements Builder<GCountryDTO, GCountryDTOBuilder> {
  _$GCountryDTO _$v;

  bool _isAvailable;
  bool get isAvailable => _$this._isAvailable;
  set isAvailable(bool isAvailable) => _$this._isAvailable = isAvailable;

  double _order;
  double get order => _$this._order;
  set order(double order) => _$this._order = order;

  GCountryDTOBuilder();

  GCountryDTOBuilder get _$this {
    if (_$v != null) {
      _isAvailable = _$v.isAvailable;
      _order = _$v.order;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GCountryDTO other) {
    if (other == null) {
      throw new ArgumentError.notNull('other');
    }
    _$v = other as _$GCountryDTO;
  }

  @override
  void update(void Function(GCountryDTOBuilder) updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GCountryDTO build() {
    final _$result =
        _$v ?? new _$GCountryDTO._(isAvailable: isAvailable, order: order);
    replace(_$result);
    return _$result;
  }
}

class _$GDepositRequestDto extends GDepositRequestDto {
  @override
  final String evidence;
  @override
  final GEvidenceType evidenceType;
  @override
  final String transferSource;

  factory _$GDepositRequestDto(
          [void Function(GDepositRequestDtoBuilder) updates]) =>
      (new GDepositRequestDtoBuilder()..update(updates)).build();

  _$GDepositRequestDto._(
      {this.evidence, this.evidenceType, this.transferSource})
      : super._() {
    if (evidence == null) {
      throw new BuiltValueNullFieldError('GDepositRequestDto', 'evidence');
    }
    if (evidenceType == null) {
      throw new BuiltValueNullFieldError('GDepositRequestDto', 'evidenceType');
    }
    if (transferSource == null) {
      throw new BuiltValueNullFieldError(
          'GDepositRequestDto', 'transferSource');
    }
  }

  @override
  GDepositRequestDto rebuild(
          void Function(GDepositRequestDtoBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GDepositRequestDtoBuilder toBuilder() =>
      new GDepositRequestDtoBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GDepositRequestDto &&
        evidence == other.evidence &&
        evidenceType == other.evidenceType &&
        transferSource == other.transferSource;
  }

  @override
  int get hashCode {
    return $jf($jc($jc($jc(0, evidence.hashCode), evidenceType.hashCode),
        transferSource.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GDepositRequestDto')
          ..add('evidence', evidence)
          ..add('evidenceType', evidenceType)
          ..add('transferSource', transferSource))
        .toString();
  }
}

class GDepositRequestDtoBuilder
    implements Builder<GDepositRequestDto, GDepositRequestDtoBuilder> {
  _$GDepositRequestDto _$v;

  String _evidence;
  String get evidence => _$this._evidence;
  set evidence(String evidence) => _$this._evidence = evidence;

  GEvidenceType _evidenceType;
  GEvidenceType get evidenceType => _$this._evidenceType;
  set evidenceType(GEvidenceType evidenceType) =>
      _$this._evidenceType = evidenceType;

  String _transferSource;
  String get transferSource => _$this._transferSource;
  set transferSource(String transferSource) =>
      _$this._transferSource = transferSource;

  GDepositRequestDtoBuilder();

  GDepositRequestDtoBuilder get _$this {
    if (_$v != null) {
      _evidence = _$v.evidence;
      _evidenceType = _$v.evidenceType;
      _transferSource = _$v.transferSource;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GDepositRequestDto other) {
    if (other == null) {
      throw new ArgumentError.notNull('other');
    }
    _$v = other as _$GDepositRequestDto;
  }

  @override
  void update(void Function(GDepositRequestDtoBuilder) updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GDepositRequestDto build() {
    final _$result = _$v ??
        new _$GDepositRequestDto._(
            evidence: evidence,
            evidenceType: evidenceType,
            transferSource: transferSource);
    replace(_$result);
    return _$result;
  }
}

class _$GFixtureDTO extends GFixtureDTO {
  @override
  final bool isAvailable;

  factory _$GFixtureDTO([void Function(GFixtureDTOBuilder) updates]) =>
      (new GFixtureDTOBuilder()..update(updates)).build();

  _$GFixtureDTO._({this.isAvailable}) : super._() {
    if (isAvailable == null) {
      throw new BuiltValueNullFieldError('GFixtureDTO', 'isAvailable');
    }
  }

  @override
  GFixtureDTO rebuild(void Function(GFixtureDTOBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GFixtureDTOBuilder toBuilder() => new GFixtureDTOBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GFixtureDTO && isAvailable == other.isAvailable;
  }

  @override
  int get hashCode {
    return $jf($jc(0, isAvailable.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GFixtureDTO')
          ..add('isAvailable', isAvailable))
        .toString();
  }
}

class GFixtureDTOBuilder implements Builder<GFixtureDTO, GFixtureDTOBuilder> {
  _$GFixtureDTO _$v;

  bool _isAvailable;
  bool get isAvailable => _$this._isAvailable;
  set isAvailable(bool isAvailable) => _$this._isAvailable = isAvailable;

  GFixtureDTOBuilder();

  GFixtureDTOBuilder get _$this {
    if (_$v != null) {
      _isAvailable = _$v.isAvailable;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GFixtureDTO other) {
    if (other == null) {
      throw new ArgumentError.notNull('other');
    }
    _$v = other as _$GFixtureDTO;
  }

  @override
  void update(void Function(GFixtureDTOBuilder) updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GFixtureDTO build() {
    final _$result = _$v ?? new _$GFixtureDTO._(isAvailable: isAvailable);
    replace(_$result);
    return _$result;
  }
}

class _$GLeagueDTO extends GLeagueDTO {
  @override
  final bool isAvailable;
  @override
  final bool isTop;

  factory _$GLeagueDTO([void Function(GLeagueDTOBuilder) updates]) =>
      (new GLeagueDTOBuilder()..update(updates)).build();

  _$GLeagueDTO._({this.isAvailable, this.isTop}) : super._();

  @override
  GLeagueDTO rebuild(void Function(GLeagueDTOBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GLeagueDTOBuilder toBuilder() => new GLeagueDTOBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GLeagueDTO &&
        isAvailable == other.isAvailable &&
        isTop == other.isTop;
  }

  @override
  int get hashCode {
    return $jf($jc($jc(0, isAvailable.hashCode), isTop.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GLeagueDTO')
          ..add('isAvailable', isAvailable)
          ..add('isTop', isTop))
        .toString();
  }
}

class GLeagueDTOBuilder implements Builder<GLeagueDTO, GLeagueDTOBuilder> {
  _$GLeagueDTO _$v;

  bool _isAvailable;
  bool get isAvailable => _$this._isAvailable;
  set isAvailable(bool isAvailable) => _$this._isAvailable = isAvailable;

  bool _isTop;
  bool get isTop => _$this._isTop;
  set isTop(bool isTop) => _$this._isTop = isTop;

  GLeagueDTOBuilder();

  GLeagueDTOBuilder get _$this {
    if (_$v != null) {
      _isAvailable = _$v.isAvailable;
      _isTop = _$v.isTop;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GLeagueDTO other) {
    if (other == null) {
      throw new ArgumentError.notNull('other');
    }
    _$v = other as _$GLeagueDTO;
  }

  @override
  void update(void Function(GLeagueDTOBuilder) updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GLeagueDTO build() {
    final _$result =
        _$v ?? new _$GLeagueDTO._(isAvailable: isAvailable, isTop: isTop);
    replace(_$result);
    return _$result;
  }
}

class _$GLocationDTO extends GLocationDTO {
  @override
  final double lat;
  @override
  final double lon;

  factory _$GLocationDTO([void Function(GLocationDTOBuilder) updates]) =>
      (new GLocationDTOBuilder()..update(updates)).build();

  _$GLocationDTO._({this.lat, this.lon}) : super._() {
    if (lat == null) {
      throw new BuiltValueNullFieldError('GLocationDTO', 'lat');
    }
    if (lon == null) {
      throw new BuiltValueNullFieldError('GLocationDTO', 'lon');
    }
  }

  @override
  GLocationDTO rebuild(void Function(GLocationDTOBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GLocationDTOBuilder toBuilder() => new GLocationDTOBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GLocationDTO && lat == other.lat && lon == other.lon;
  }

  @override
  int get hashCode {
    return $jf($jc($jc(0, lat.hashCode), lon.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GLocationDTO')
          ..add('lat', lat)
          ..add('lon', lon))
        .toString();
  }
}

class GLocationDTOBuilder
    implements Builder<GLocationDTO, GLocationDTOBuilder> {
  _$GLocationDTO _$v;

  double _lat;
  double get lat => _$this._lat;
  set lat(double lat) => _$this._lat = lat;

  double _lon;
  double get lon => _$this._lon;
  set lon(double lon) => _$this._lon = lon;

  GLocationDTOBuilder();

  GLocationDTOBuilder get _$this {
    if (_$v != null) {
      _lat = _$v.lat;
      _lon = _$v.lon;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GLocationDTO other) {
    if (other == null) {
      throw new ArgumentError.notNull('other');
    }
    _$v = other as _$GLocationDTO;
  }

  @override
  void update(void Function(GLocationDTOBuilder) updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GLocationDTO build() {
    final _$result = _$v ?? new _$GLocationDTO._(lat: lat, lon: lon);
    replace(_$result);
    return _$result;
  }
}

class _$GLoginDto extends GLoginDto {
  @override
  final String password;
  @override
  final String username;

  factory _$GLoginDto([void Function(GLoginDtoBuilder) updates]) =>
      (new GLoginDtoBuilder()..update(updates)).build();

  _$GLoginDto._({this.password, this.username}) : super._() {
    if (password == null) {
      throw new BuiltValueNullFieldError('GLoginDto', 'password');
    }
    if (username == null) {
      throw new BuiltValueNullFieldError('GLoginDto', 'username');
    }
  }

  @override
  GLoginDto rebuild(void Function(GLoginDtoBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GLoginDtoBuilder toBuilder() => new GLoginDtoBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GLoginDto &&
        password == other.password &&
        username == other.username;
  }

  @override
  int get hashCode {
    return $jf($jc($jc(0, password.hashCode), username.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GLoginDto')
          ..add('password', password)
          ..add('username', username))
        .toString();
  }
}

class GLoginDtoBuilder implements Builder<GLoginDto, GLoginDtoBuilder> {
  _$GLoginDto _$v;

  String _password;
  String get password => _$this._password;
  set password(String password) => _$this._password = password;

  String _username;
  String get username => _$this._username;
  set username(String username) => _$this._username = username;

  GLoginDtoBuilder();

  GLoginDtoBuilder get _$this {
    if (_$v != null) {
      _password = _$v.password;
      _username = _$v.username;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GLoginDto other) {
    if (other == null) {
      throw new ArgumentError.notNull('other');
    }
    _$v = other as _$GLoginDto;
  }

  @override
  void update(void Function(GLoginDtoBuilder) updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GLoginDto build() {
    final _$result =
        _$v ?? new _$GLoginDto._(password: password, username: username);
    replace(_$result);
    return _$result;
  }
}

class _$GMarketDTO extends GMarketDTO {
  @override
  final bool isAvailable;

  factory _$GMarketDTO([void Function(GMarketDTOBuilder) updates]) =>
      (new GMarketDTOBuilder()..update(updates)).build();

  _$GMarketDTO._({this.isAvailable}) : super._() {
    if (isAvailable == null) {
      throw new BuiltValueNullFieldError('GMarketDTO', 'isAvailable');
    }
  }

  @override
  GMarketDTO rebuild(void Function(GMarketDTOBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GMarketDTOBuilder toBuilder() => new GMarketDTOBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GMarketDTO && isAvailable == other.isAvailable;
  }

  @override
  int get hashCode {
    return $jf($jc(0, isAvailable.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GMarketDTO')
          ..add('isAvailable', isAvailable))
        .toString();
  }
}

class GMarketDTOBuilder implements Builder<GMarketDTO, GMarketDTOBuilder> {
  _$GMarketDTO _$v;

  bool _isAvailable;
  bool get isAvailable => _$this._isAvailable;
  set isAvailable(bool isAvailable) => _$this._isAvailable = isAvailable;

  GMarketDTOBuilder();

  GMarketDTOBuilder get _$this {
    if (_$v != null) {
      _isAvailable = _$v.isAvailable;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GMarketDTO other) {
    if (other == null) {
      throw new ArgumentError.notNull('other');
    }
    _$v = other as _$GMarketDTO;
  }

  @override
  void update(void Function(GMarketDTOBuilder) updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GMarketDTO build() {
    final _$result = _$v ?? new _$GMarketDTO._(isAvailable: isAvailable);
    replace(_$result);
    return _$result;
  }
}

class _$GShopDto extends GShopDto {
  @override
  final String adminId;
  @override
  final String branchName;
  @override
  final BuiltList<GContactDTO> contacts;
  @override
  final bool isActive;
  @override
  final GLocationDTO location;

  factory _$GShopDto([void Function(GShopDtoBuilder) updates]) =>
      (new GShopDtoBuilder()..update(updates)).build();

  _$GShopDto._(
      {this.adminId,
      this.branchName,
      this.contacts,
      this.isActive,
      this.location})
      : super._() {
    if (adminId == null) {
      throw new BuiltValueNullFieldError('GShopDto', 'adminId');
    }
    if (branchName == null) {
      throw new BuiltValueNullFieldError('GShopDto', 'branchName');
    }
    if (contacts == null) {
      throw new BuiltValueNullFieldError('GShopDto', 'contacts');
    }
  }

  @override
  GShopDto rebuild(void Function(GShopDtoBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GShopDtoBuilder toBuilder() => new GShopDtoBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GShopDto &&
        adminId == other.adminId &&
        branchName == other.branchName &&
        contacts == other.contacts &&
        isActive == other.isActive &&
        location == other.location;
  }

  @override
  int get hashCode {
    return $jf($jc(
        $jc(
            $jc($jc($jc(0, adminId.hashCode), branchName.hashCode),
                contacts.hashCode),
            isActive.hashCode),
        location.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GShopDto')
          ..add('adminId', adminId)
          ..add('branchName', branchName)
          ..add('contacts', contacts)
          ..add('isActive', isActive)
          ..add('location', location))
        .toString();
  }
}

class GShopDtoBuilder implements Builder<GShopDto, GShopDtoBuilder> {
  _$GShopDto _$v;

  String _adminId;
  String get adminId => _$this._adminId;
  set adminId(String adminId) => _$this._adminId = adminId;

  String _branchName;
  String get branchName => _$this._branchName;
  set branchName(String branchName) => _$this._branchName = branchName;

  ListBuilder<GContactDTO> _contacts;
  ListBuilder<GContactDTO> get contacts =>
      _$this._contacts ??= new ListBuilder<GContactDTO>();
  set contacts(ListBuilder<GContactDTO> contacts) =>
      _$this._contacts = contacts;

  bool _isActive;
  bool get isActive => _$this._isActive;
  set isActive(bool isActive) => _$this._isActive = isActive;

  GLocationDTOBuilder _location;
  GLocationDTOBuilder get location =>
      _$this._location ??= new GLocationDTOBuilder();
  set location(GLocationDTOBuilder location) => _$this._location = location;

  GShopDtoBuilder();

  GShopDtoBuilder get _$this {
    if (_$v != null) {
      _adminId = _$v.adminId;
      _branchName = _$v.branchName;
      _contacts = _$v.contacts?.toBuilder();
      _isActive = _$v.isActive;
      _location = _$v.location?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GShopDto other) {
    if (other == null) {
      throw new ArgumentError.notNull('other');
    }
    _$v = other as _$GShopDto;
  }

  @override
  void update(void Function(GShopDtoBuilder) updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GShopDto build() {
    _$GShopDto _$result;
    try {
      _$result = _$v ??
          new _$GShopDto._(
              adminId: adminId,
              branchName: branchName,
              contacts: contacts.build(),
              isActive: isActive,
              location: _location?.build());
    } catch (_) {
      String _$failedField;
      try {
        _$failedField = 'contacts';
        contacts.build();

        _$failedField = 'location';
        _location?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'GShopDto', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$GSportDTO extends GSportDTO {
  @override
  final bool isAvailable;
  @override
  final double order;

  factory _$GSportDTO([void Function(GSportDTOBuilder) updates]) =>
      (new GSportDTOBuilder()..update(updates)).build();

  _$GSportDTO._({this.isAvailable, this.order}) : super._() {
    if (isAvailable == null) {
      throw new BuiltValueNullFieldError('GSportDTO', 'isAvailable');
    }
  }

  @override
  GSportDTO rebuild(void Function(GSportDTOBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GSportDTOBuilder toBuilder() => new GSportDTOBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GSportDTO &&
        isAvailable == other.isAvailable &&
        order == other.order;
  }

  @override
  int get hashCode {
    return $jf($jc($jc(0, isAvailable.hashCode), order.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GSportDTO')
          ..add('isAvailable', isAvailable)
          ..add('order', order))
        .toString();
  }
}

class GSportDTOBuilder implements Builder<GSportDTO, GSportDTOBuilder> {
  _$GSportDTO _$v;

  bool _isAvailable;
  bool get isAvailable => _$this._isAvailable;
  set isAvailable(bool isAvailable) => _$this._isAvailable = isAvailable;

  double _order;
  double get order => _$this._order;
  set order(double order) => _$this._order = order;

  GSportDTOBuilder();

  GSportDTOBuilder get _$this {
    if (_$v != null) {
      _isAvailable = _$v.isAvailable;
      _order = _$v.order;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GSportDTO other) {
    if (other == null) {
      throw new ArgumentError.notNull('other');
    }
    _$v = other as _$GSportDTO;
  }

  @override
  void update(void Function(GSportDTOBuilder) updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GSportDTO build() {
    final _$result =
        _$v ?? new _$GSportDTO._(isAvailable: isAvailable, order: order);
    replace(_$result);
    return _$result;
  }
}

class _$GTicketDTO extends GTicketDTO {
  @override
  final BuiltList<GBetDTO> bets;
  @override
  final double stake;

  factory _$GTicketDTO([void Function(GTicketDTOBuilder) updates]) =>
      (new GTicketDTOBuilder()..update(updates)).build();

  _$GTicketDTO._({this.bets, this.stake}) : super._() {
    if (bets == null) {
      throw new BuiltValueNullFieldError('GTicketDTO', 'bets');
    }
    if (stake == null) {
      throw new BuiltValueNullFieldError('GTicketDTO', 'stake');
    }
  }

  @override
  GTicketDTO rebuild(void Function(GTicketDTOBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GTicketDTOBuilder toBuilder() => new GTicketDTOBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GTicketDTO && bets == other.bets && stake == other.stake;
  }

  @override
  int get hashCode {
    return $jf($jc($jc(0, bets.hashCode), stake.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GTicketDTO')
          ..add('bets', bets)
          ..add('stake', stake))
        .toString();
  }
}

class GTicketDTOBuilder implements Builder<GTicketDTO, GTicketDTOBuilder> {
  _$GTicketDTO _$v;

  ListBuilder<GBetDTO> _bets;
  ListBuilder<GBetDTO> get bets => _$this._bets ??= new ListBuilder<GBetDTO>();
  set bets(ListBuilder<GBetDTO> bets) => _$this._bets = bets;

  double _stake;
  double get stake => _$this._stake;
  set stake(double stake) => _$this._stake = stake;

  GTicketDTOBuilder();

  GTicketDTOBuilder get _$this {
    if (_$v != null) {
      _bets = _$v.bets?.toBuilder();
      _stake = _$v.stake;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GTicketDTO other) {
    if (other == null) {
      throw new ArgumentError.notNull('other');
    }
    _$v = other as _$GTicketDTO;
  }

  @override
  void update(void Function(GTicketDTOBuilder) updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GTicketDTO build() {
    _$GTicketDTO _$result;
    try {
      _$result = _$v ?? new _$GTicketDTO._(bets: bets.build(), stake: stake);
    } catch (_) {
      String _$failedField;
      try {
        _$failedField = 'bets';
        bets.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'GTicketDTO', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$GTransactionDTO extends GTransactionDTO {
  @override
  final double amount;
  @override
  final String customer;
  @override
  final GTransactionType type;

  factory _$GTransactionDTO([void Function(GTransactionDTOBuilder) updates]) =>
      (new GTransactionDTOBuilder()..update(updates)).build();

  _$GTransactionDTO._({this.amount, this.customer, this.type}) : super._() {
    if (amount == null) {
      throw new BuiltValueNullFieldError('GTransactionDTO', 'amount');
    }
    if (customer == null) {
      throw new BuiltValueNullFieldError('GTransactionDTO', 'customer');
    }
    if (type == null) {
      throw new BuiltValueNullFieldError('GTransactionDTO', 'type');
    }
  }

  @override
  GTransactionDTO rebuild(void Function(GTransactionDTOBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GTransactionDTOBuilder toBuilder() =>
      new GTransactionDTOBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GTransactionDTO &&
        amount == other.amount &&
        customer == other.customer &&
        type == other.type;
  }

  @override
  int get hashCode {
    return $jf(
        $jc($jc($jc(0, amount.hashCode), customer.hashCode), type.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GTransactionDTO')
          ..add('amount', amount)
          ..add('customer', customer)
          ..add('type', type))
        .toString();
  }
}

class GTransactionDTOBuilder
    implements Builder<GTransactionDTO, GTransactionDTOBuilder> {
  _$GTransactionDTO _$v;

  double _amount;
  double get amount => _$this._amount;
  set amount(double amount) => _$this._amount = amount;

  String _customer;
  String get customer => _$this._customer;
  set customer(String customer) => _$this._customer = customer;

  GTransactionType _type;
  GTransactionType get type => _$this._type;
  set type(GTransactionType type) => _$this._type = type;

  GTransactionDTOBuilder();

  GTransactionDTOBuilder get _$this {
    if (_$v != null) {
      _amount = _$v.amount;
      _customer = _$v.customer;
      _type = _$v.type;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GTransactionDTO other) {
    if (other == null) {
      throw new ArgumentError.notNull('other');
    }
    _$v = other as _$GTransactionDTO;
  }

  @override
  void update(void Function(GTransactionDTOBuilder) updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GTransactionDTO build() {
    final _$result = _$v ??
        new _$GTransactionDTO._(amount: amount, customer: customer, type: type);
    replace(_$result);
    return _$result;
  }
}

class _$GUpdateDepositRequestDto extends GUpdateDepositRequestDto {
  @override
  final double amount;

  factory _$GUpdateDepositRequestDto(
          [void Function(GUpdateDepositRequestDtoBuilder) updates]) =>
      (new GUpdateDepositRequestDtoBuilder()..update(updates)).build();

  _$GUpdateDepositRequestDto._({this.amount}) : super._() {
    if (amount == null) {
      throw new BuiltValueNullFieldError('GUpdateDepositRequestDto', 'amount');
    }
  }

  @override
  GUpdateDepositRequestDto rebuild(
          void Function(GUpdateDepositRequestDtoBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GUpdateDepositRequestDtoBuilder toBuilder() =>
      new GUpdateDepositRequestDtoBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GUpdateDepositRequestDto && amount == other.amount;
  }

  @override
  int get hashCode {
    return $jf($jc(0, amount.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GUpdateDepositRequestDto')
          ..add('amount', amount))
        .toString();
  }
}

class GUpdateDepositRequestDtoBuilder
    implements
        Builder<GUpdateDepositRequestDto, GUpdateDepositRequestDtoBuilder> {
  _$GUpdateDepositRequestDto _$v;

  double _amount;
  double get amount => _$this._amount;
  set amount(double amount) => _$this._amount = amount;

  GUpdateDepositRequestDtoBuilder();

  GUpdateDepositRequestDtoBuilder get _$this {
    if (_$v != null) {
      _amount = _$v.amount;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GUpdateDepositRequestDto other) {
    if (other == null) {
      throw new ArgumentError.notNull('other');
    }
    _$v = other as _$GUpdateDepositRequestDto;
  }

  @override
  void update(void Function(GUpdateDepositRequestDtoBuilder) updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GUpdateDepositRequestDto build() {
    final _$result = _$v ?? new _$GUpdateDepositRequestDto._(amount: amount);
    replace(_$result);
    return _$result;
  }
}

class _$GUpdateShopDTO extends GUpdateShopDTO {
  @override
  final String adminId;
  @override
  final String branchName;
  @override
  final BuiltList<GContactDTO> contacts;
  @override
  final bool isActive;
  @override
  final GLocationDTO location;

  factory _$GUpdateShopDTO([void Function(GUpdateShopDTOBuilder) updates]) =>
      (new GUpdateShopDTOBuilder()..update(updates)).build();

  _$GUpdateShopDTO._(
      {this.adminId,
      this.branchName,
      this.contacts,
      this.isActive,
      this.location})
      : super._() {
    if (contacts == null) {
      throw new BuiltValueNullFieldError('GUpdateShopDTO', 'contacts');
    }
  }

  @override
  GUpdateShopDTO rebuild(void Function(GUpdateShopDTOBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GUpdateShopDTOBuilder toBuilder() =>
      new GUpdateShopDTOBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GUpdateShopDTO &&
        adminId == other.adminId &&
        branchName == other.branchName &&
        contacts == other.contacts &&
        isActive == other.isActive &&
        location == other.location;
  }

  @override
  int get hashCode {
    return $jf($jc(
        $jc(
            $jc($jc($jc(0, adminId.hashCode), branchName.hashCode),
                contacts.hashCode),
            isActive.hashCode),
        location.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GUpdateShopDTO')
          ..add('adminId', adminId)
          ..add('branchName', branchName)
          ..add('contacts', contacts)
          ..add('isActive', isActive)
          ..add('location', location))
        .toString();
  }
}

class GUpdateShopDTOBuilder
    implements Builder<GUpdateShopDTO, GUpdateShopDTOBuilder> {
  _$GUpdateShopDTO _$v;

  String _adminId;
  String get adminId => _$this._adminId;
  set adminId(String adminId) => _$this._adminId = adminId;

  String _branchName;
  String get branchName => _$this._branchName;
  set branchName(String branchName) => _$this._branchName = branchName;

  ListBuilder<GContactDTO> _contacts;
  ListBuilder<GContactDTO> get contacts =>
      _$this._contacts ??= new ListBuilder<GContactDTO>();
  set contacts(ListBuilder<GContactDTO> contacts) =>
      _$this._contacts = contacts;

  bool _isActive;
  bool get isActive => _$this._isActive;
  set isActive(bool isActive) => _$this._isActive = isActive;

  GLocationDTOBuilder _location;
  GLocationDTOBuilder get location =>
      _$this._location ??= new GLocationDTOBuilder();
  set location(GLocationDTOBuilder location) => _$this._location = location;

  GUpdateShopDTOBuilder();

  GUpdateShopDTOBuilder get _$this {
    if (_$v != null) {
      _adminId = _$v.adminId;
      _branchName = _$v.branchName;
      _contacts = _$v.contacts?.toBuilder();
      _isActive = _$v.isActive;
      _location = _$v.location?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GUpdateShopDTO other) {
    if (other == null) {
      throw new ArgumentError.notNull('other');
    }
    _$v = other as _$GUpdateShopDTO;
  }

  @override
  void update(void Function(GUpdateShopDTOBuilder) updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GUpdateShopDTO build() {
    _$GUpdateShopDTO _$result;
    try {
      _$result = _$v ??
          new _$GUpdateShopDTO._(
              adminId: adminId,
              branchName: branchName,
              contacts: contacts.build(),
              isActive: isActive,
              location: _location?.build());
    } catch (_) {
      String _$failedField;
      try {
        _$failedField = 'contacts';
        contacts.build();

        _$failedField = 'location';
        _location?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'GUpdateShopDTO', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$GUpdateTicketDTO extends GUpdateTicketDTO {
  @override
  final bool isPlaced;
  @override
  final double stake;

  factory _$GUpdateTicketDTO(
          [void Function(GUpdateTicketDTOBuilder) updates]) =>
      (new GUpdateTicketDTOBuilder()..update(updates)).build();

  _$GUpdateTicketDTO._({this.isPlaced, this.stake}) : super._();

  @override
  GUpdateTicketDTO rebuild(void Function(GUpdateTicketDTOBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GUpdateTicketDTOBuilder toBuilder() =>
      new GUpdateTicketDTOBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GUpdateTicketDTO &&
        isPlaced == other.isPlaced &&
        stake == other.stake;
  }

  @override
  int get hashCode {
    return $jf($jc($jc(0, isPlaced.hashCode), stake.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GUpdateTicketDTO')
          ..add('isPlaced', isPlaced)
          ..add('stake', stake))
        .toString();
  }
}

class GUpdateTicketDTOBuilder
    implements Builder<GUpdateTicketDTO, GUpdateTicketDTOBuilder> {
  _$GUpdateTicketDTO _$v;

  bool _isPlaced;
  bool get isPlaced => _$this._isPlaced;
  set isPlaced(bool isPlaced) => _$this._isPlaced = isPlaced;

  double _stake;
  double get stake => _$this._stake;
  set stake(double stake) => _$this._stake = stake;

  GUpdateTicketDTOBuilder();

  GUpdateTicketDTOBuilder get _$this {
    if (_$v != null) {
      _isPlaced = _$v.isPlaced;
      _stake = _$v.stake;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GUpdateTicketDTO other) {
    if (other == null) {
      throw new ArgumentError.notNull('other');
    }
    _$v = other as _$GUpdateTicketDTO;
  }

  @override
  void update(void Function(GUpdateTicketDTOBuilder) updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GUpdateTicketDTO build() {
    final _$result =
        _$v ?? new _$GUpdateTicketDTO._(isPlaced: isPlaced, stake: stake);
    replace(_$result);
    return _$result;
  }
}

class _$GUserDto extends GUserDto {
  @override
  final String belongsToShop;
  @override
  final BuiltList<GCashierPermission> cashierPermissions;
  @override
  final String firstName;
  @override
  final String lastName;
  @override
  final String password;
  @override
  final GRole role;
  @override
  final String username;

  factory _$GUserDto([void Function(GUserDtoBuilder) updates]) =>
      (new GUserDtoBuilder()..update(updates)).build();

  _$GUserDto._(
      {this.belongsToShop,
      this.cashierPermissions,
      this.firstName,
      this.lastName,
      this.password,
      this.role,
      this.username})
      : super._() {
    if (cashierPermissions == null) {
      throw new BuiltValueNullFieldError('GUserDto', 'cashierPermissions');
    }
    if (firstName == null) {
      throw new BuiltValueNullFieldError('GUserDto', 'firstName');
    }
    if (lastName == null) {
      throw new BuiltValueNullFieldError('GUserDto', 'lastName');
    }
    if (password == null) {
      throw new BuiltValueNullFieldError('GUserDto', 'password');
    }
    if (username == null) {
      throw new BuiltValueNullFieldError('GUserDto', 'username');
    }
  }

  @override
  GUserDto rebuild(void Function(GUserDtoBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GUserDtoBuilder toBuilder() => new GUserDtoBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GUserDto &&
        belongsToShop == other.belongsToShop &&
        cashierPermissions == other.cashierPermissions &&
        firstName == other.firstName &&
        lastName == other.lastName &&
        password == other.password &&
        role == other.role &&
        username == other.username;
  }

  @override
  int get hashCode {
    return $jf($jc(
        $jc(
            $jc(
                $jc(
                    $jc(
                        $jc($jc(0, belongsToShop.hashCode),
                            cashierPermissions.hashCode),
                        firstName.hashCode),
                    lastName.hashCode),
                password.hashCode),
            role.hashCode),
        username.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GUserDto')
          ..add('belongsToShop', belongsToShop)
          ..add('cashierPermissions', cashierPermissions)
          ..add('firstName', firstName)
          ..add('lastName', lastName)
          ..add('password', password)
          ..add('role', role)
          ..add('username', username))
        .toString();
  }
}

class GUserDtoBuilder implements Builder<GUserDto, GUserDtoBuilder> {
  _$GUserDto _$v;

  String _belongsToShop;
  String get belongsToShop => _$this._belongsToShop;
  set belongsToShop(String belongsToShop) =>
      _$this._belongsToShop = belongsToShop;

  ListBuilder<GCashierPermission> _cashierPermissions;
  ListBuilder<GCashierPermission> get cashierPermissions =>
      _$this._cashierPermissions ??= new ListBuilder<GCashierPermission>();
  set cashierPermissions(ListBuilder<GCashierPermission> cashierPermissions) =>
      _$this._cashierPermissions = cashierPermissions;

  String _firstName;
  String get firstName => _$this._firstName;
  set firstName(String firstName) => _$this._firstName = firstName;

  String _lastName;
  String get lastName => _$this._lastName;
  set lastName(String lastName) => _$this._lastName = lastName;

  String _password;
  String get password => _$this._password;
  set password(String password) => _$this._password = password;

  GRole _role;
  GRole get role => _$this._role;
  set role(GRole role) => _$this._role = role;

  String _username;
  String get username => _$this._username;
  set username(String username) => _$this._username = username;

  GUserDtoBuilder();

  GUserDtoBuilder get _$this {
    if (_$v != null) {
      _belongsToShop = _$v.belongsToShop;
      _cashierPermissions = _$v.cashierPermissions?.toBuilder();
      _firstName = _$v.firstName;
      _lastName = _$v.lastName;
      _password = _$v.password;
      _role = _$v.role;
      _username = _$v.username;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GUserDto other) {
    if (other == null) {
      throw new ArgumentError.notNull('other');
    }
    _$v = other as _$GUserDto;
  }

  @override
  void update(void Function(GUserDtoBuilder) updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GUserDto build() {
    _$GUserDto _$result;
    try {
      _$result = _$v ??
          new _$GUserDto._(
              belongsToShop: belongsToShop,
              cashierPermissions: cashierPermissions.build(),
              firstName: firstName,
              lastName: lastName,
              password: password,
              role: role,
              username: username);
    } catch (_) {
      String _$failedField;
      try {
        _$failedField = 'cashierPermissions';
        cashierPermissions.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'GUserDto', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$GUserUpdateDTO extends GUserUpdateDTO {
  @override
  final String belongsToShop;
  @override
  final BuiltList<GCashierPermission> cashierPermissions;
  @override
  final String firstName;
  @override
  final String lastName;
  @override
  final String password;
  @override
  final GRole role;
  @override
  final String username;

  factory _$GUserUpdateDTO([void Function(GUserUpdateDTOBuilder) updates]) =>
      (new GUserUpdateDTOBuilder()..update(updates)).build();

  _$GUserUpdateDTO._(
      {this.belongsToShop,
      this.cashierPermissions,
      this.firstName,
      this.lastName,
      this.password,
      this.role,
      this.username})
      : super._() {
    if (cashierPermissions == null) {
      throw new BuiltValueNullFieldError(
          'GUserUpdateDTO', 'cashierPermissions');
    }
  }

  @override
  GUserUpdateDTO rebuild(void Function(GUserUpdateDTOBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GUserUpdateDTOBuilder toBuilder() =>
      new GUserUpdateDTOBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GUserUpdateDTO &&
        belongsToShop == other.belongsToShop &&
        cashierPermissions == other.cashierPermissions &&
        firstName == other.firstName &&
        lastName == other.lastName &&
        password == other.password &&
        role == other.role &&
        username == other.username;
  }

  @override
  int get hashCode {
    return $jf($jc(
        $jc(
            $jc(
                $jc(
                    $jc(
                        $jc($jc(0, belongsToShop.hashCode),
                            cashierPermissions.hashCode),
                        firstName.hashCode),
                    lastName.hashCode),
                password.hashCode),
            role.hashCode),
        username.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GUserUpdateDTO')
          ..add('belongsToShop', belongsToShop)
          ..add('cashierPermissions', cashierPermissions)
          ..add('firstName', firstName)
          ..add('lastName', lastName)
          ..add('password', password)
          ..add('role', role)
          ..add('username', username))
        .toString();
  }
}

class GUserUpdateDTOBuilder
    implements Builder<GUserUpdateDTO, GUserUpdateDTOBuilder> {
  _$GUserUpdateDTO _$v;

  String _belongsToShop;
  String get belongsToShop => _$this._belongsToShop;
  set belongsToShop(String belongsToShop) =>
      _$this._belongsToShop = belongsToShop;

  ListBuilder<GCashierPermission> _cashierPermissions;
  ListBuilder<GCashierPermission> get cashierPermissions =>
      _$this._cashierPermissions ??= new ListBuilder<GCashierPermission>();
  set cashierPermissions(ListBuilder<GCashierPermission> cashierPermissions) =>
      _$this._cashierPermissions = cashierPermissions;

  String _firstName;
  String get firstName => _$this._firstName;
  set firstName(String firstName) => _$this._firstName = firstName;

  String _lastName;
  String get lastName => _$this._lastName;
  set lastName(String lastName) => _$this._lastName = lastName;

  String _password;
  String get password => _$this._password;
  set password(String password) => _$this._password = password;

  GRole _role;
  GRole get role => _$this._role;
  set role(GRole role) => _$this._role = role;

  String _username;
  String get username => _$this._username;
  set username(String username) => _$this._username = username;

  GUserUpdateDTOBuilder();

  GUserUpdateDTOBuilder get _$this {
    if (_$v != null) {
      _belongsToShop = _$v.belongsToShop;
      _cashierPermissions = _$v.cashierPermissions?.toBuilder();
      _firstName = _$v.firstName;
      _lastName = _$v.lastName;
      _password = _$v.password;
      _role = _$v.role;
      _username = _$v.username;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GUserUpdateDTO other) {
    if (other == null) {
      throw new ArgumentError.notNull('other');
    }
    _$v = other as _$GUserUpdateDTO;
  }

  @override
  void update(void Function(GUserUpdateDTOBuilder) updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GUserUpdateDTO build() {
    _$GUserUpdateDTO _$result;
    try {
      _$result = _$v ??
          new _$GUserUpdateDTO._(
              belongsToShop: belongsToShop,
              cashierPermissions: cashierPermissions.build(),
              firstName: firstName,
              lastName: lastName,
              password: password,
              role: role,
              username: username);
    } catch (_) {
      String _$failedField;
      try {
        _$failedField = 'cashierPermissions';
        cashierPermissions.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'GUserUpdateDTO', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$GUpload extends GUpload {
  @override
  final String value;

  factory _$GUpload([void Function(GUploadBuilder) updates]) =>
      (new GUploadBuilder()..update(updates)).build();

  _$GUpload._({this.value}) : super._() {
    if (value == null) {
      throw new BuiltValueNullFieldError('GUpload', 'value');
    }
  }

  @override
  GUpload rebuild(void Function(GUploadBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GUploadBuilder toBuilder() => new GUploadBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GUpload && value == other.value;
  }

  @override
  int get hashCode {
    return $jf($jc(0, value.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GUpload')..add('value', value))
        .toString();
  }
}

class GUploadBuilder implements Builder<GUpload, GUploadBuilder> {
  _$GUpload _$v;

  String _value;
  String get value => _$this._value;
  set value(String value) => _$this._value = value;

  GUploadBuilder();

  GUploadBuilder get _$this {
    if (_$v != null) {
      _value = _$v.value;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GUpload other) {
    if (other == null) {
      throw new ArgumentError.notNull('other');
    }
    _$v = other as _$GUpload;
  }

  @override
  void update(void Function(GUploadBuilder) updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GUpload build() {
    final _$result = _$v ?? new _$GUpload._(value: value);
    replace(_$result);
    return _$result;
  }
}

// ignore_for_file: always_put_control_body_on_new_line,always_specify_types,annotate_overrides,avoid_annotating_with_dynamic,avoid_as,avoid_catches_without_on_clauses,avoid_returning_this,lines_longer_than_80_chars,omit_local_variable_types,prefer_expression_function_bodies,sort_constructors_first,test_types_in_equals,unnecessary_const,unnecessary_new
